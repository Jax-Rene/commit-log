{{template "base" .}}

{{define "content"}}
{{$content := ""}}
{{if .post}}
        {{if .post.Content}}
                {{$content = .post.Content}}
        {{end}}
{{end}}
{{$initial := dict "content" $content "post" .post "latestPublication" .latestPublication "allTags" .allTags "tagError" .tagError}}

<style>
        body {
                background-color: #fdfcff;
        }

        body.milkdown-immersive {
                background-color: #fdfcff;
                overflow-x: hidden;
        }

        body.milkdown-immersive header,
        body.milkdown-immersive footer {
                display: none !important;
        }

        body.milkdown-immersive main {
                max-width: 100vw !important;
                width: 100vw !important;
                padding: 0 !important;
                min-height: 100vh;
        }

        body.milkdown-immersive main > * {
                margin: 0;
                min-height: 100vh;
        }

        .milkdown-immersive-shell {
                position: relative;
                display: flex;
                flex-direction: column;
                height: 100%;
                overflow: hidden;
        }

        .milkdown-immersive-wrapper {
                flex: 1 1 auto;
                display: flex;
                overflow-x: hidden;
                overflow-y: auto;
                min-height: 0;
        }

        .milkdown-immersive-container {
                flex: 1 1 auto;
                display: flex;
                flex-direction: column;
                min-height: 100%;
        }

        .milkdown-immersive-shell .milkdown {
                flex: 1 1 auto;
                min-height: 0;
                overflow-x: hidden;
                overflow-y: auto;
                --crepe-color-background: #fdfcff;
                background-color: #fdfcff;
        }

        .milkdown-preview .milkdown {
                background-color: transparent;
                box-shadow: none;
        }

        .milkdown-preview .milkdown .ProseMirror {
                padding: 0;
        }
</style>

<div class="milkdown-immersive-shell" x-data="postEditorShell()" x-init="init()" x-cloak>
        <div class="milkdown-immersive-wrapper">
                <div class="milkdown-immersive-container mx-auto flex w-full max-w-screen-xl flex-col px-6 pt-24 pb-10 md:px-12 md:pb-24 lg:px-16 xl:px-20 2xl:max-w-screen-2xl 2xl:px-24">
                        <div id="milkdown-app" class="milkdown"></div>
                </div>
        </div>

        <div class="pointer-events-none fixed bottom-6 right-6 z-40 flex flex-col items-end gap-3">
                <div class="pointer-events-auto flex flex-col items-end gap-3" @mouseenter="handleQuickActionsMouseEnter()" @mouseleave="handleQuickActionsMouseLeave()" @focusin="handleQuickActionsMouseEnter()" @focusout="handleQuickActionsFocusOut($event)" @click.outside="handleQuickActionsOutside()">
                        <div x-show="quickActionsExpanded" x-transition.opacity x-transition.scale.origin-bottom-right class="w-72 max-w-[calc(100vw-48px)] rounded-2xl border border-slate-200 bg-white/95 p-4 text-sm shadow-xl shadow-slate-200/80 backdrop-blur supports-backdrop-blur:bg-white/80 dark:border-slate-700 dark:bg-slate-900/90 dark:shadow-slate-900/40">
                                <div class="flex items-center justify-between">
                                        <div class="flex items-center gap-2 text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500">
                                                <span>写作助手</span>
                                                <span class="h-1.5 w-1.5 rounded-full" :class="autoSaveIndicatorClasses()"></span>
                                        </div>
                                        <button type="button" class="rounded-full p-1 text-slate-400 transition hover:text-slate-600 dark:text-slate-500 dark:hover:text-slate-300" @click="collapseQuickActions()" aria-label="收起工具面板">
                                                <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 12h12"></path>
                                                </svg>
                                        </button>
                                </div>
                                <p class="mt-2 text-xs leading-relaxed text-slate-500 dark:text-slate-400" x-text="autoSaveLabel()"></p>
                                <div class="mt-3 grid gap-2">
                                        <button type="button" class="inline-flex items-center justify-center gap-2 rounded-xl bg-blue-600 px-4 py-2 font-medium text-white transition hover:bg-blue-500 disabled:cursor-not-allowed disabled:bg-slate-300 dark:hover:bg-blue-500/90 dark:disabled:bg-slate-700/70" @click="triggerSave()" :disabled="savingDraft">
                                                <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M16.5 3.75h-9A2.25 2.25 0 0 0 5.25 6v12A2.25 2.25 0 0 0 7.5 20.25h9A2.25 2.25 0 0 0 18.75 18V6A2.25 2.25 0 0 0 16.5 3.75Z"></path>
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9.75 7.5h4.5M9.75 12h4.5m-4.5 4.5h2.25"></path>
                                                </svg>
                                                <span x-show="!savingDraft">保存草稿</span>
                                                <span x-show="savingDraft">保存中...</span>
                                        </button>
                                        <div class="rounded-xl border border-emerald-200 bg-emerald-50/70 p-3 text-xs text-slate-600 shadow-sm dark:border-emerald-500/40 dark:bg-emerald-500/10 dark:text-slate-200">
                                                <div class="flex items-start justify-between gap-3">
                                                        <div>
                                                                <p class="text-[11px] font-semibold uppercase tracking-wide text-emerald-600 dark:text-emerald-300">发布状态</p>
                                                                <p class="mt-1 text-sm font-medium text-slate-700 dark:text-slate-100" x-text="publishStatusLabel()"></p>
                                                        </div>
                                                        <button type="button" class="inline-flex items-center gap-2 rounded-lg bg-emerald-500 px-3 py-1.5 text-xs font-semibold text-white transition hover:bg-emerald-500/90 disabled:cursor-not-allowed disabled:bg-emerald-300 dark:bg-emerald-400 dark:hover:bg-emerald-300/80 dark:disabled:bg-emerald-600/60" @click="publishArticle()" :disabled="publishing || savingDraft">
                                                                <svg class="h-3.5 w-3.5" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 5v14M7 10l5-5 5 5"></path>
                                                                </svg>
                                                                <span x-show="!publishing" x-text="publishButtonLabel()"></span>
                                                                <span x-show="publishing">发布中...</span>
                                                        </button>
                                                </div>
                                                <p class="mt-2 leading-relaxed text-[11px] text-slate-500 dark:text-slate-400" x-text="publishStatusDescription()"></p>
                                        </div>
                                        <button type="button" class="inline-flex items-center justify-center gap-2 rounded-xl bg-emerald-500 px-4 py-2 font-semibold text-white transition hover:bg-emerald-500/90 disabled:cursor-not-allowed disabled:bg-emerald-300 dark:bg-emerald-500/90 dark:hover:bg-emerald-400 dark:disabled:bg-emerald-700/70" @click="optimizeContent()" :disabled="optimizingContent">
                                                <svg class="h-4 w-4 text-emerald-100 transition-colors dark:text-emerald-200" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 3v2.25M19.5 12H21M3 12h2.25M16.95 7.05l1.59-1.59M5.46 18.54l1.59-1.59M7.05 7.05 5.46 5.46M18.54 18.54l-1.59-1.59M12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Z"></path>
                                                </svg>
                                                <span x-show="!optimizingContent">AI 全文优化</span>
                                                <span x-show="optimizingContent">优化中...</span>
                                        </button>
                                        <div class="relative">
                                                <button type="button" class="inline-flex w-full items-center justify-center gap-2 rounded-xl border border-slate-200 px-4 py-2 font-medium text-slate-600 transition hover:border-blue-200 hover:text-blue-600 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/60 dark:hover:text-blue-200" @click="toggleStatisticsMenu()" :aria-expanded="statisticsMenuOpen">
                                                        <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4.5 19.5h15M7.5 15l3-4.5 3 3 3-4.5"></path>
                                                        </svg>
                                                        <span>Statistics</span>
                                                        <svg class="h-3.5 w-3.5 text-slate-400 transition-transform dark:text-slate-500" :class="statisticsMenuOpen ? 'rotate-180' : ''" viewBox="0 0 20 20" fill="none" stroke="currentColor">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 8l4 4 4-4"></path>
                                                        </svg>
                                                </button>
                                                <div x-cloak x-show="statisticsMenuOpen" x-transition.origin-top-right class="absolute right-0 top-full z-10 mt-2 w-64 rounded-xl border border-slate-200 bg-white/95 p-3 text-xs text-slate-500 shadow-xl shadow-slate-200/80 backdrop-blur supports-backdrop-blur:bg-white/80 dark:border-slate-700 dark:bg-slate-900/95 dark:text-slate-400">
                                                        <p class="mb-2 text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500">Statistics</p>
                                                        <ul class="space-y-2">
                                                                <li class="flex items-center justify-between">
                                                                        <span class="font-medium text-slate-600 dark:text-slate-200">Words</span>
                                                                        <span class="text-sm font-semibold text-slate-900 dark:text-slate-100" x-text="formatNumber(contentMetrics?.words)"></span>
                                                                </li>
                                                                <li class="flex items-center justify-between">
                                                                        <span class="font-medium text-slate-600 dark:text-slate-200">Characters</span>
                                                                        <span class="text-sm font-semibold text-slate-900 dark:text-slate-100" x-text="formatNumber(contentMetrics?.characters)"></span>
                                                                </li>
                                                                <li class="flex items-center justify-between">
                                                                        <span class="font-medium text-slate-600 dark:text-slate-200">Paragraphs</span>
                                                                        <span class="text-sm font-semibold text-slate-900 dark:text-slate-100" x-text="paragraphCountLabel()"></span>
                                                                </li>
                                                                <li class="flex items-center justify-between">
                                                                        <span class="font-medium text-slate-600 dark:text-slate-200">Modification Date</span>
                                                                        <span class="text-sm font-medium text-slate-900 dark:text-slate-100" x-text="statisticsUpdatedLabel()"></span>
                                                                </li>
                                                                <li class="flex items-center justify-between">
                                                                        <span class="font-medium text-slate-600 dark:text-slate-200">Create Date</span>
                                                                        <span class="text-sm font-medium text-slate-900 dark:text-slate-100" x-text="statisticsCreatedLabel()"></span>
                                                                </li>
                                                        </ul>
                                                </div>
                                        </div>
                                        <button type="button" class="inline-flex items-center justify-center gap-2 rounded-xl border border-slate-200 px-4 py-2 font-medium text-slate-600 transition hover:border-blue-200 hover:text-blue-600 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/60 dark:hover:text-blue-200" @click="openMetadataPanel()">
                                                <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M8.25 6.75h7.5M8.25 12h7.5M8.25 17.25h4.5"></path>
                                                </svg>
                                                <span>文章设置</span>
                                        </button>
                                </div>
                                <div class="mt-3 flex items-center justify-between text-xs text-slate-500 dark:text-slate-400">
                                        <span class="font-medium">⌘/Ctrl + S</span>
                                        <a href="/admin/posts" class="inline-flex items-center gap-2 rounded-lg border border-slate-200 px-3 py-1.5 font-medium text-slate-600 transition hover:border-slate-300 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:border-slate-600 dark:hover:text-slate-100">
                                                <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M10.5 6h7.125M10.5 12h7.125M10.5 18H17.625M6.375 6v12l-3-3H9.375"></path>
                                                </svg>
                                                <span>返回列表</span>
                                        </a>
                                </div>
                        </div>
                        <button type="button" class="flex h-12 w-12 items-center justify-center rounded-full border border-slate-200/70 bg-white/75 text-slate-500 shadow-md shadow-slate-200/50 transition hover:bg-white focus:outline-none focus:ring-2 focus:ring-blue-100 dark:border-slate-600/70 dark:bg-slate-800/80 dark:text-slate-200 dark:hover:bg-slate-700/80" @click="toggleQuickActions()" :aria-expanded="quickActionsExpanded" aria-label="快速操作">
                                <svg x-show="!quickActionsExpanded" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 6v12M6 12h12"></path>
                                </svg>
                                <svg x-show="quickActionsExpanded" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M6 12h12"></path>
                                </svg>
                        </button>
                </div>
        </div>

        <div x-show="panelOpen" x-transition.opacity class="fixed inset-0 z-40 flex" @keydown.escape.window="closePanel()">
                <div class="hidden flex-1 bg-slate-900/40 backdrop-blur-sm md:block" @click="closePanel()"></div>
                <div class="ml-auto flex h-full w-full max-w-md flex-col bg-white shadow-2xl transition dark:bg-slate-900" x-transition:enter="transform ease-out duration-200" x-transition:enter-start="translate-x-full" x-transition:enter-end="translate-x-0" x-transition:leave="transform ease-in duration-200" x-transition:leave-start="translate-x-0" x-transition:leave-end="translate-x-full">
                        <header class="flex items-start justify-between border-b border-slate-200 px-6 pb-4 pt-6 dark:border-slate-800">
                                <div class="space-y-1">
                                        <h2 class="text-lg font-semibold text-slate-900 dark:text-slate-100">文章设置</h2>
                                        <p class="text-xs text-slate-500 dark:text-slate-400">管理文章标题、摘要与封面等元数据。</p>
                                </div>
                                <button type="button" class="rounded-full p-2 text-slate-400 transition-colors hover:text-slate-600 focus:outline-none focus:ring-2 focus:ring-slate-200 dark:text-slate-500 dark:hover:text-slate-200 dark:focus:ring-slate-700/60" @click="closePanel()">
                                        <svg class="h-4 w-4" viewBox="0 0 20 20" fill="none" stroke="currentColor">
                                                <path stroke-linecap="round" stroke-width="1.6" d="M5.5 5.5l9 9m0-9l-9 9"></path>
                                        </svg>
                                </button>
                        </header>
                        <div class="flex-1 space-y-6 overflow-y-auto px-6 pb-10 pt-6">
                                <section class="space-y-2">
                                        <label class="flex flex-col gap-2">
                                                <span class="text-sm font-medium text-slate-700 dark:text-slate-200">文章标题<span class="ml-1 text-rose-500">*</span></span>
                                                <input type="text" x-ref="titleInput" x-model="metadata.title" @input.debounce.300ms="handleTitleChange(metadata.title)" placeholder="请输入文章标题" class="w-full rounded-xl border border-slate-300 px-3 py-2 text-sm text-slate-900 placeholder-slate-400 transition-colors focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-100 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-100 dark:placeholder-slate-500 dark:focus:border-blue-500/60 dark:focus:ring-blue-500/30">
                                        </label>
                                        <p class="text-xs text-slate-500 dark:text-slate-400">标题将用于首页展示与搜索结果摘要。</p>
                                </section>

                                <section class="space-y-3">
                                        <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                                                <div>
                                                        <h3 class="text-sm font-semibold text-slate-900 dark:text-slate-100">文章摘要</h3>
                                                        <p class="text-xs text-slate-500 dark:text-slate-400">用于列表页描述和 SEO 元信息。</p>
                                                </div>
                                                <button type="button" class="inline-flex items-center gap-2 rounded-lg border border-slate-200 px-3 py-1.5 text-xs font-medium text-slate-600 transition-colors hover:border-blue-200 hover:text-blue-600 disabled:cursor-not-allowed disabled:border-slate-200 disabled:text-slate-300 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/50 dark:hover:text-blue-200 dark:disabled:border-slate-700 dark:disabled:text-slate-600" @click="generateSummary()" :disabled="generatingSummary">
                                                        <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 3v3m0 12v3m9-9h-3M6 12H3m15.364-6.364l-2.121 2.121M8.757 15.243l-2.121 2.121m0-11.314l2.121 2.121m8.486 8.486l2.121 2.121"></path>
                                                        </svg>
                                                        <span x-show="!generatingSummary">生成 AI 摘要</span>
                                                        <span x-show="generatingSummary">生成中...</span>
                                                </button>
                                        </div>
                                        <textarea rows="6" x-model="metadata.summary" @input.debounce.500ms="handleSummaryChange(metadata.summary)" placeholder="简要概括文章核心观点" class="w-full rounded-xl border border-slate-300 px-3 py-2 text-sm text-slate-900 placeholder-slate-400 transition-colors focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-100 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-100 dark:placeholder-slate-500 dark:focus:border-blue-500/60 dark:focus:ring-blue-500/30"></textarea>
                                        <template x-if="summaryUsage">
                                                <p class="text-xs text-slate-400 dark:text-slate-500">提示词用量：<span x-text="summaryUsageLabel()"></span></p>
                                        </template>
                                </section>

                                <section class="space-y-4">
                                        <div class="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between">
                                                <div>
                                                        <h3 class="text-sm font-semibold text-slate-900 dark:text-slate-100">文章标签</h3>
                                                        <p class="text-xs text-slate-500 dark:text-slate-400">为文章挑选合适标签，帮助归档与专题聚合。</p>
                                                </div>
                                                <a href="/admin/tags" class="inline-flex items-center gap-1 text-xs font-medium text-blue-600 transition hover:text-blue-500 dark:text-blue-300 dark:hover:text-blue-200">
                                                        <svg class="h-3.5 w-3.5" viewBox="0 0 20 20" fill="none" stroke="currentColor">
                                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.4" d="M10 4.167v11.666M4.167 10h11.666"></path>
                                                        </svg>
                                                        <span>管理标签</span>
                                                </a>
                                        </div>
                                        <template x-if="tagError">
                                                <div class="rounded-xl border border-rose-200 bg-rose-50/80 px-4 py-3 text-xs text-rose-600 dark:border-rose-500/40 dark:bg-rose-500/10 dark:text-rose-200" x-text="tagError"></div>
                                        </template>
                                        <div class="rounded-xl border border-slate-200/80 bg-white/70 px-3 py-3 dark:border-slate-700 dark:bg-slate-900/40" x-show="availableTags.length > 0" x-cloak>
                                                <div class="max-h-60 space-y-2 overflow-y-auto pr-1">
                                                        <template x-for="tag in availableTags" :key="`panel-tag-${tag.id}`">
                                                                <label class="flex items-center gap-3 rounded-lg px-2 py-1.5 text-sm text-slate-600 transition hover:bg-slate-50 dark:text-slate-300 dark:hover:bg-slate-800/60">
                                                                        <input type="checkbox" class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500 dark:border-slate-600 dark:bg-slate-800" :value="tag.id" :checked="isTagSelected(tag.id)" @change="toggleTag(tag)">
                                                                        <span class="truncate" x-text="tag.name"></span>
                                                                </label>
                                                        </template>
                                                </div>
                                        </div>
                                        <div x-show="!tagError && availableTags.length === 0" x-cloak class="rounded-xl border border-dashed border-slate-200 px-4 py-3 text-xs text-slate-500 dark:border-slate-700 dark:text-slate-400">
                                                暂无可用标签，请先前往标签管理创建。
                                        </div>
                                        <div class="flex flex-wrap items-center gap-2 text-[11px] text-slate-400 dark:text-slate-500">
                                                <span class="font-semibold uppercase tracking-wide">已选择</span>
                                                <template x-if="metadata.tags.length === 0">
                                                        <span class="rounded-full bg-slate-100 px-2 py-0.5 font-medium text-slate-500 dark:bg-slate-800/70 dark:text-slate-300">未选择</span>
                                                </template>
                                                <template x-for="tag in metadata.tags" :key="`panel-selected-${tag.id}`">
                                                        <span class="rounded-full bg-blue-50 px-2 py-0.5 text-xs font-medium text-blue-600 dark:bg-blue-500/20 dark:text-blue-200" x-text="tag.name"></span>
                                                </template>
                                        </div>
                                </section>

                                <section class="space-y-3">
                                        <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                                                <div>
                                                        <h3 class="text-sm font-semibold text-slate-900 dark:text-slate-100">文章封面<span class="ml-2 rounded-full bg-slate-100 px-2 py-0.5 text-[11px] font-medium text-slate-500 dark:bg-slate-800/70 dark:text-slate-400">发布前必填</span></h3>
                                                        <p class="text-xs text-slate-500 dark:text-slate-400">建议尺寸 ≥ 1200px，可裁剪为 16:9 或 3:4。</p>
                                                </div>
                                                <div class="flex flex-wrap items-center gap-2">
                                                        <input type="file" accept="image/*" class="hidden" x-ref="coverInput" @change="handleCoverFile($event)">
                                                        <button type="button" class="inline-flex items-center gap-2 rounded-lg border border-slate-300 px-3 py-1.5 text-xs font-medium text-slate-600 transition-colors hover:border-blue-300 hover:bg-blue-50 hover:text-blue-600 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/60 dark:hover:bg-blue-500/10 dark:hover:text-blue-200" @click="openCoverPicker()">选择图片</button>
                                                        <button type="button" class="inline-flex items-center gap-2 rounded-lg border border-slate-200 px-3 py-1.5 text-xs font-medium text-slate-600 transition-colors hover:border-slate-300 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:border-slate-600 dark:hover:text-slate-100" @click="reCropCover()" x-show="metadata.cover.url" x-cloak>重新裁剪</button>
                                                </div>
                                        </div>
                                        <div x-show="metadata.cover.url" x-cloak class="space-y-4 rounded-xl border border-slate-200 bg-slate-50/70 p-4 transition-colors dark:border-slate-700 dark:bg-slate-900/60">
                                                <div class="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
                                                        <div class="flex items-center gap-4">
                                                                <img :src="metadata.cover.url" alt="封面预览" class="h-28 w-28 rounded-lg object-cover shadow-sm">
                                                                <div class="space-y-1 text-xs text-slate-600 dark:text-slate-300">
                                                                        <p class="font-medium text-slate-800 dark:text-slate-100">当前封面</p>
                                                                        <p class="text-slate-500 dark:text-slate-400">尺寸：<span x-text="formatCoverSize()"></span></p>
                                                                        <p class="text-[11px] text-slate-400 dark:text-slate-500">保存后将自动适配首页与分享卡片。</p>
                                                                </div>
                                                        </div>
                                                        <div class="flex items-center gap-2 text-xs">
                                                                <button type="button" class="rounded-lg border border-slate-200 px-3 py-1.5 font-medium text-slate-600 transition-colors hover:bg-slate-100 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800 dark:hover:text-slate-100" @click="reCropCover()">重新裁剪</button>
                                                                <button type="button" class="rounded-lg border border-rose-200 px-3 py-1.5 font-medium text-rose-600 transition-colors hover:bg-rose-50 dark:border-rose-500/50 dark:text-rose-300 dark:hover:bg-rose-500/10" @click="removeCover()">移除</button>
                                                        </div>
                                                </div>
                                        </div>
                                        <div x-show="!metadata.cover.url" class="rounded-xl border border-dashed border-slate-200 bg-white/70 p-6 text-xs text-slate-500 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-400">
                                                还没有封面，上传后可用于首页展示与社交分享卡片。
                                        </div>
                                </section>

                                <section class="rounded-xl border border-slate-200 bg-slate-50/60 p-4 text-xs text-slate-500 transition-colors dark:border-slate-800 dark:bg-slate-900/60 dark:text-slate-400">
                                        <div class="flex items-center gap-2 text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500">
                                                <span>草稿状态</span>
                                                <span class="h-1.5 w-1.5 rounded-full" :class="autoSaveIndicatorClasses()"></span>
                                        </div>
                                        <p class="mt-2 leading-relaxed" x-text="autoSaveDescription()"></p>
                                </section>
                        </div>
                </div>
        </div>

        <div x-show="optimizationModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 px-4">
                <div class="relative w-full max-w-5xl rounded-2xl border border-slate-200 bg-white p-6 shadow-2xl transition-colors dark:border-slate-800 dark:bg-slate-950">
                        <div class="flex items-start justify-between gap-4">
                                <div>
                                        <h3 class="text-lg font-semibold text-slate-900 dark:text-slate-100">AI 全文优化预览</h3>
                                        <p class="mt-1 text-sm text-slate-500 dark:text-slate-400">左右对照新旧版本，确认后可一键替换。</p>
                                </div>
                                <button type="button" class="rounded-full p-1.5 text-slate-400 transition hover:text-slate-600 dark:text-slate-500 dark:hover:text-slate-300" @click="closeOptimizationModal()" aria-label="关闭优化预览">
                                        ✕
                                </button>
                        </div>
                        <template x-if="optimizationUsage">
                                <div class="mt-4 flex flex-wrap items-center gap-2 text-xs text-slate-500 dark:text-slate-400">
                                        <span class="inline-flex items-center gap-1 rounded-full bg-slate-100 px-3 py-1 dark:bg-slate-800/70">
                                                <span class="text-slate-500 dark:text-slate-400">提示词 Token：</span>
                                                <span x-text="optimizationUsage.prompt_tokens ?? optimizationUsage.promptTokens"></span>
                                        </span>
                                        <span class="inline-flex items-center gap-1 rounded-full bg-slate-100 px-3 py-1 dark:bg-slate-800/70">
                                                <span class="text-slate-500 dark:text-slate-400">生成 Token：</span>
                                                <span x-text="optimizationUsage.completion_tokens ?? optimizationUsage.completionTokens"></span>
                                        </span>
                                </div>
                        </template>
                        <div class="relative mt-4">
                                <div x-show="optimizingContent" x-cloak class="absolute inset-0 z-10 flex items-center justify-center rounded-xl border border-dashed border-slate-300 bg-white/85 backdrop-blur-sm dark:border-slate-700 dark:bg-slate-950/80">
                                        <div class="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300">
                                                <span class="animate-pulse">正在优化全文...</span>
                                        </div>
                                </div>
                                <div class="grid gap-4 lg:grid-cols-2">
                                        <div class="rounded-xl border border-slate-200 bg-white p-4 dark:border-slate-700 dark:bg-slate-900/70">
                                                <div class="flex items-center justify-between text-xs font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500">
                                                        <span>当前正文</span>
                                                </div>
                                                <div class="mt-3 max-h-[60vh] overflow-y-auto rounded-lg border border-slate-100/80 bg-slate-50/60 px-4 py-3 text-sm leading-6 text-slate-700 dark:border-slate-700/60 dark:bg-slate-900/40 dark:text-slate-200">
                                                        <div x-show="!optimizationPreviews.source.ready" class="text-xs text-slate-400 dark:text-slate-500">暂无内容</div>
                                                        <div x-ref="optimizationSourcePreview" x-show="optimizationPreviews.source.ready" class="milkdown-preview"></div>
                                                </div>
                                        </div>
                                        <div class="rounded-xl border border-emerald-200 bg-emerald-50/70 p-4 text-sm leading-6 text-slate-700 dark:border-emerald-500/40 dark:bg-emerald-500/10 dark:text-emerald-100">
                                                <div class="flex items-center justify-between text-xs font-semibold uppercase tracking-wide">
                                                        <span>优化提案</span>
                                                </div>
                                                <div class="mt-3 max-h-[60vh] overflow-y-auto rounded-lg border border-emerald-200/60 bg-white/70 px-4 py-3 text-sm leading-6 text-slate-700 dark:border-emerald-500/30 dark:bg-slate-900/60 dark:text-emerald-50">
                                                        <div x-show="!optimizationPreviews.optimized.ready" class="text-xs text-emerald-500/70 dark:text-emerald-200/70">等待优化结果...</div>
                                                        <div x-ref="optimizedContentPreview" x-show="optimizationPreviews.optimized.ready" class="milkdown-preview"></div>
                                                </div>
                                        </div>
                                </div>
                        </div>
                        <div class="mt-6 flex justify-end gap-3 text-sm">
                                <button type="button" class="rounded-lg border border-slate-200 px-4 py-2 text-slate-600 transition hover:bg-slate-100 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800 dark:hover:text-slate-100" @click="closeOptimizationModal()">关闭</button>
                                <button type="button" class="rounded-lg border border-emerald-200 px-4 py-2 font-medium text-emerald-600 transition hover:bg-emerald-50 disabled:cursor-not-allowed disabled:text-slate-400 dark:border-emerald-500/40 dark:text-emerald-300 dark:hover:bg-emerald-500/10" @click="optimizeContent()" :disabled="optimizingContent">重新生成</button>
                                <button type="button" class="rounded-lg bg-emerald-600 px-4 py-2 font-medium text-white transition hover:bg-emerald-500 dark:hover:bg-emerald-500/90" @click="applyOptimization()">替换正文</button>
                        </div>
                </div>
        </div>

        <div x-show="inlineAI.open" x-cloak class="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/50 px-4 backdrop-blur-sm" @keydown.escape.window="closeInlineAI()">
                <div class="relative w-full max-w-3xl overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-2xl transition-colors dark:border-slate-800 dark:bg-slate-950" x-trap.noscroll="inlineAI.open">
                        <div class="flex items-start justify-between gap-4 border-b border-slate-200 px-6 py-4 dark:border-slate-800">
                                <div>
                                        <h3 class="text-lg font-semibold text-slate-900 dark:text-slate-100">AI Chat 改写</h3>
                                        <p class="mt-1 text-xs text-slate-500 dark:text-slate-400">选中段落后输入你的需求，模型将返回改写建议。</p>
                                </div>
                                <button type="button" class="rounded-full p-1.5 text-slate-400 transition hover:text-slate-600 dark:text-slate-500 dark:hover:text-slate-300" @click="closeInlineAI()" aria-label="关闭 AI Chat 弹窗">✕</button>
                        </div>
                        <div class="flex max-h-[70vh] flex-col gap-5 overflow-y-auto px-6 py-6">
                                <div class="space-y-2">
                                        <p class="text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500">原始选区</p>
                                        <div class="rounded-xl border border-slate-200 bg-slate-50/80 p-3 text-xs leading-relaxed text-slate-700 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-300 whitespace-pre-wrap break-words" x-text="inlineAI.selection.text || inlineAI.selection.normalized"></div>
                                        <template x-if="inlineAI.selection.context && inlineAI.selection.context.trim() && inlineAI.selection.context.trim() !== (inlineAI.selection.text || inlineAI.selection.normalized || '').trim()">
                                                <div class="space-y-2">
                                                        <p class="text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500">上下文参考</p>
                                                        <div class="rounded-xl border border-dashed border-slate-200 bg-white p-3 text-xs leading-relaxed text-slate-600 dark:border-slate-700 dark:bg-slate-900/50 dark:text-slate-300 whitespace-pre-wrap break-words" x-text="inlineAI.selection.context"></div>
                                                </div>
                                        </template>
                                </div>
                                <div class="space-y-2">
                                        <label class="text-sm font-medium text-slate-700 dark:text-slate-200">改写指令</label>
                                        <textarea rows="3" x-model="inlineAI.instruction" placeholder="例如：请改写成更具鼓动性的语气，并保留原有数据引用。" class="w-full resize-y rounded-xl border border-slate-300 px-3 py-2 text-sm text-slate-900 placeholder-slate-400 transition focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-100 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-100 dark:placeholder-slate-500 dark:focus:border-blue-400 dark:focus:ring-blue-500/40"></textarea>
                                </div>
                                <template x-if="inlineAI.error">
                                        <div class="rounded-xl border border-rose-200 bg-rose-50/80 px-3 py-2 text-xs text-rose-600 dark:border-rose-500/50 dark:bg-rose-500/10 dark:text-rose-200" x-text="inlineAI.error"></div>
                                </template>
                                <div class="flex flex-wrap items-center gap-3">
                                        <button type="button" class="inline-flex items-center gap-2 rounded-xl bg-blue-600 px-4 py-2 text-sm font-medium text-white transition hover:bg-blue-500 disabled:cursor-not-allowed disabled:bg-slate-300 dark:bg-blue-500 dark:hover:bg-blue-400 dark:disabled:bg-slate-700/70" @click="runInlineAIChat()" :disabled="inlineAI.loading">
                                                <svg x-show="inlineAI.loading" class="h-4 w-4 animate-spin" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 3v3m4.95 1.05-2.12 2.12M21 12h-3m-1.05 4.95-2.12-2.12M12 21v-3m-4.95-1.05 2.12-2.12M3 12h3m1.05-4.95 2.12 2.12"></path></svg>
                                                <svg x-show="!inlineAI.loading" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M12 3l2.5 6.5L21 11l-5 4.5 1.5 6.5L12 18l-5.5 4 1.5-6.5L3 11l6.5-1.5L12 3z"></path></svg>
                                                <span x-text="inlineAI.loading ? '生成中…' : '生成改写建议'"></span>
                                        </button>
                                        <template x-if="inlineAI.usage">
                                                <span class="rounded-full bg-slate-100 px-3 py-1 text-[11px] font-semibold text-slate-500 dark:bg-slate-800/70 dark:text-slate-300" x-text="inlineAIUsageLabel()"></span>
                                        </template>
                                </div>
                                <template x-if="inlineAI.suggestion">
                                        <div class="space-y-2">
                                                <p class="text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500">AI 改写建议</p>
                                                <div class="rounded-xl border border-blue-200 bg-blue-50/70 p-3 text-sm leading-relaxed text-slate-800 dark:border-blue-500/40 dark:bg-blue-500/10 dark:text-slate-200 whitespace-pre-wrap break-words" x-text="inlineAI.suggestion"></div>
                                        </div>
                                </template>
                        </div>
                        <div class="flex flex-wrap items-center justify-between gap-3 border-t border-slate-200 bg-slate-50 px-6 py-4 dark:border-slate-800 dark:bg-slate-900/60">
                                <div class="flex items-center gap-2">
                                        <button type="button" class="inline-flex items-center gap-2 rounded-xl border border-slate-300 px-4 py-2 text-sm font-medium text-slate-600 transition hover:border-slate-400 hover:text-slate-900 disabled:cursor-not-allowed disabled:opacity-60 dark:border-slate-700 dark:text-slate-300 dark:hover:border-slate-500 dark:hover:text-slate-100" @click="copyInlineAISuggestion()" :disabled="!inlineAI.suggestion">
                                                <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M9 9V5.25A2.25 2.25 0 0 1 11.25 3h7.5A2.25 2.25 0 0 1 21 5.25v7.5A2.25 2.25 0 0 1 18.75 15H15m-6 6H5.25A2.25 2.25 0 0 1 3 18.75v-7.5A2.25 2.25 0 0 1 5.25 9h7.5A2.25 2.25 0 0 1 15 11.25v7.5A2.25 2.25 0 0 1 12.75 21H9Z"></path></svg>
                                                <span>复制建议</span>
                                        </button>
                                </div>
                                <div class="flex items-center gap-3">
                                        <button type="button" class="rounded-xl border border-slate-300 px-4 py-2 text-sm font-medium text-slate-600 transition hover:border-slate-400 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:border-slate-500 dark:hover:text-slate-100" @click="closeInlineAI()">取消</button>
                                        <button type="button" class="inline-flex items-center gap-2 rounded-xl bg-slate-900 px-4 py-2 text-sm font-semibold text-white transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:bg-slate-400 dark:bg-blue-500 dark:hover:bg-blue-400 dark:disabled:bg-slate-700" @click="applyInlineAISuggestion()" :disabled="!inlineAI.suggestion">应用到选区</button>
                                </div>
                        </div>
                </div>
        </div>

        <div x-show="coverModal" x-cloak class="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 px-4">
                <div class="relative w-full max-w-3xl rounded-2xl bg-white p-6 shadow-2xl transition-colors dark:bg-slate-950">
                        <h3 class="text-lg font-semibold text-slate-900 dark:text-slate-100">裁剪封面</h3>
                        <div class="mt-4 flex flex-col gap-4">
                                <div class="flex flex-wrap items-center gap-2 text-xs text-slate-500 dark:text-slate-400">
                                        <span class="font-medium text-slate-600 dark:text-slate-300">裁剪比例：</span>
                                        <button type="button" class="rounded-lg border px-3 py-1.5 transition-colors" :class="cropAspect === '16:9' ? 'border-blue-500 bg-blue-50 text-blue-600 dark:border-blue-400/70 dark:bg-blue-500/10 dark:text-blue-200' : 'border-slate-200 text-slate-600 hover:bg-slate-100 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800'" @click="setAspect('16:9')">16 : 9</button>
                                        <button type="button" class="rounded-lg border px-3 py-1.5 transition-colors" :class="cropAspect === '3:4' ? 'border-blue-500 bg-blue-50 text-blue-600 dark:border-blue-400/70 dark:bg-blue-500/10 dark:text-blue-200' : 'border-slate-200 text-slate-600 hover:bg-slate-100 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800'" @click="setAspect('3:4')">3 : 4</button>
                                </div>
                                <div class="max-h-[60vh] overflow-hidden rounded-xl border border-slate-200 dark:border-slate-700">
                                        <img x-ref="cropperImage" :src="coverSource" alt="裁剪预览" class="max-h-[60vh] w-full object-contain" />
                                </div>
                        </div>
                        <div class="mt-6 flex justify-end gap-3 text-sm">
                                <button type="button" class="rounded-lg border border-slate-200 px-4 py-2 text-slate-600 transition-colors hover:bg-slate-100 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800 dark:hover:text-slate-100" @click="closeCropper()" :disabled="uploadingCover">取消</button>
                                <button type="button" class="rounded-lg bg-blue-600 px-4 py-2 text-white transition-colors hover:bg-blue-500 disabled:cursor-not-allowed disabled:bg-slate-300 dark:hover:bg-blue-500/90 dark:disabled:bg-slate-700/70" @click="confirmCrop()" :disabled="uploadingCover">
                                        <span x-show="!uploadingCover">确认裁剪</span>
                                        <span x-show="uploadingCover">上传中...</span>
                                </button>
                        </div>
                </div>
        </div>
</div>

<script>
window.__MILKDOWN_V2__ = {{$initial | toJSON}};
document.body.classList.add('milkdown-immersive');
const milkdownCleanup = () => {
        document.body.classList.remove('milkdown-immersive');
        const controller = window.MilkdownV2?.controller;
        if (controller && typeof controller.dispose === 'function') {
                try {
                        controller.dispose();
                } catch (error) {
                        console.error('[milkdown] 清理控制器失败', error);
                }
        }
        const crepe = window.MilkdownV2?.crepe;
        if (crepe && typeof crepe.destroy === 'function') {
                void crepe.destroy();
        }
};
window.addEventListener('pagehide', milkdownCleanup, { once: true });
window.addEventListener('beforeunload', milkdownCleanup, { once: true });
</script>
<script>
document.addEventListener('alpine:init', () => {
        const sanitizeString = value => (typeof value === 'string' ? value : '');
        const sanitizeNumber = value => {
                const parsed = Number(value);
                return Number.isFinite(parsed) ? parsed : 0;
        };
        const toDate = value => {
                if (!value) {
                        return null;
                }
                if (value instanceof Date && !Number.isNaN(value.getTime())) {
                        return value;
                }
                const timestamp = Date.parse(value);
                if (Number.isNaN(timestamp)) {
                        return null;
                }
                return new Date(timestamp);
        };
        const escapeHtml = text =>
                text
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');

        const fallbackMarkdownToHtml = value => {
                const blocks = value
                        .split(/\n{2,}/)
                        .map(block => `<p class="whitespace-pre-wrap break-words">${escapeHtml(block).replace(/\n/g, '<br>')}</p>`)
                        .join('');
                return `<div class="space-y-4">${blocks}</div>`;
        };

        const toast = window.AdminUI?.toast || (payload => {
                const message = typeof payload === 'string' ? payload : payload?.message;
                if (message) {
                        console.log('[toast]', message);
                }
        });

        Alpine.data('postEditorShell', () => ({
                controller: null,
                contentMetrics: { words: 0, characters: 0, paragraphs: 0 },
                numberFormatter: null,
                handleMetricsUpdate: null,
                handlePublicationUpdate: null,
                panelOpen: false,
                quickActionsExpanded: false,
                quickActionsHovering: false,
                quickActionsTimer: null,
                statisticsMenuOpen: false,
                availableTags: [],
                selectedTagIDs: [],
                tagError: '',
                postCreatedAt: '',
                postUpdatedAt: '',
                metadata: {
                        title: '',
                        summary: '',
                        cover: { url: '', width: 0, height: 0 },
                        tags: [],
                },
                summaryUsage: null,
                optimizationUsage: null,
                generatingSummary: false,
                optimizingContent: false,
                savingDraft: false,
                autoSaving: false,
                autoSavePending: false,
                autoSaveError: '',
                lastAutoSavedAt: null,
                postId: 'new',
                coverModal: false,
                coverSource: '',
                cropper: null,
                cropAspect: '16:9',
                uploadingCover: false,
                optimizationModal: false,
                optimizationSource: '',
                optimizedContent: '',
                optimizationPreviews: {
                        source: { instance: null, mount: null, ready: false, rendering: null },
                        optimized: { instance: null, mount: null, ready: false, rendering: null },
                },
                inlineAI: {
                        open: false,
                        instruction: '',
                        selection: { from: 0, to: 0, text: '', normalized: '', context: '', revision: 0 },
                        suggestion: '',
                        usage: null,
                        loading: false,
                        error: '',
                },
                statusTimer: null,
                handleInlineAIRequest: null,
                latestPublication: null,
                publishing: false,
                init() {
                        this.availableTags = this.normalizeTags(window.__MILKDOWN_V2__?.allTags || []);
                        this.tagError = sanitizeString(window.__MILKDOWN_V2__?.tagError || '');
                        if (window.__MILKDOWN_V2__?.post) {
                                this.syncTagsFromController(window.__MILKDOWN_V2__.post);
                        }
                        this.numberFormatter = new Intl.NumberFormat('zh-CN');
                        this.latestPublication = window.__MILKDOWN_V2__?.latestPublication || null;
                        this.handleMetricsUpdate = event => {
                                const detail = event?.detail || {};
                                if (detail.metrics) {
                                        this.applyContentMetrics(detail.metrics);
                                } else if (detail.controller?.contentMetrics) {
                                        this.applyContentMetrics(detail.controller.contentMetrics);
                                }
                        };
                        this.handleInlineAIRequest = event => {
                                const selection = event?.detail?.selection || {};
                                const normalized = sanitizeString(selection.normalizedText || selection.text || '');
                                if (!normalized.trim()) {
                                        toast({ message: '请选择需要改写的段落后再试', type: 'warning' });
                                        return;
                                }
                                const from = typeof selection.from === 'number' && Number.isFinite(selection.from)
                                        ? selection.from
                                        : 0;
                                const to = typeof selection.to === 'number' && Number.isFinite(selection.to)
                                        ? selection.to
                                        : 0;
                                const context = sanitizeString(selection.context || '');
                                const revision = typeof selection.revision === 'number' && Number.isFinite(selection.revision)
                                        ? selection.revision
                                        : 0;
                                this.inlineAI.open = true;
                                this.inlineAI.instruction = '';
                                this.inlineAI.loading = false;
                                this.inlineAI.error = '';
                                this.inlineAI.suggestion = '';
                                this.inlineAI.usage = null;
                                this.inlineAI.selection = {
                                        from,
                                        to,
                                        text: sanitizeString(selection.text || normalized),
                                        normalized,
                                        context,
                                        revision,
                                };
                                if (window.MilkdownV2?.inlineAI?.hideToolbar) {
                                        try {
                                                window.MilkdownV2.inlineAI.hideToolbar();
                                        } catch (error) {
                                                console.warn('[post-editor] 隐藏 AI Chat 工具条失败', error);
                                        }
                                }
                        };
                        this.handlePublicationUpdate = event => {
                                const publication = event?.detail?.publication;
                                if (publication && typeof publication === 'object') {
                                        this.latestPublication = publication;
                                }
                        };
                        this.handleReady = event => {
                                if (event?.detail?.controller) {
                                        this.attachController(event.detail.controller);
                                }
                                if (event?.detail?.post) {
                                        this.syncPost(event.detail.post);
                                }
                                this.refreshStatus();
                        };
                        this.handlePostUpdate = event => {
                                if (event?.detail?.controller) {
                                        this.attachController(event.detail.controller);
                                }
                                if (event?.detail?.post) {
                                        this.syncPost(event.detail.post);
                                }
                                this.refreshStatus();
                        };
                        window.addEventListener('post-editor:inline-ai', this.handleInlineAIRequest);
                        window.addEventListener('post-editor:publication', this.handlePublicationUpdate);
                        window.addEventListener('post-editor:ready', this.handleReady);
                        window.addEventListener('post-editor:post-updated', this.handlePostUpdate);
                        window.addEventListener('post-editor:dirty', () => this.refreshStatus());
                        window.addEventListener('post-editor:metrics', this.handleMetricsUpdate);
                        this.tryAttachController();
                        this.refreshStatus();
                        this.statusTimer = window.setInterval(() => this.refreshStatus(), 3000);
                        this.cleanup = () => {
                                if (this.statusTimer) {
                                        window.clearInterval(this.statusTimer);
                                        this.statusTimer = null;
                                }
                                this.cancelQuickActionsTimer();
                                window.removeEventListener('post-editor:ready', this.handleReady);
                                window.removeEventListener('post-editor:post-updated', this.handlePostUpdate);
                                if (this.handleMetricsUpdate) {
                                        window.removeEventListener('post-editor:metrics', this.handleMetricsUpdate);
                                        this.handleMetricsUpdate = null;
                                }
                                if (this.handleInlineAIRequest) {
                                        window.removeEventListener('post-editor:inline-ai', this.handleInlineAIRequest);
                                        this.handleInlineAIRequest = null;
                                }
                                if (this.handlePublicationUpdate) {
                                        window.removeEventListener('post-editor:publication', this.handlePublicationUpdate);
                                        this.handlePublicationUpdate = null;
                                }
                                void this.destroyOptimizationPreview('source');
                                void this.destroyOptimizationPreview('optimized');
                        };
                        window.addEventListener('pagehide', this.cleanup, { once: true });
                        window.addEventListener('beforeunload', this.cleanup, { once: true });
                },
                toggleQuickActions() {
                        this.quickActionsExpanded = !this.quickActionsExpanded;
                        if (this.quickActionsExpanded) {
                                this.closeStatisticsMenu();
                                this.cancelQuickActionsTimer();
                                this.scheduleQuickActionsCollapse();
                        } else {
                                this.closeStatisticsMenu();
                                this.cancelQuickActionsTimer();
                        }
                },
                collapseQuickActions() {
                        if (!this.quickActionsExpanded) {
                                return;
                        }
                        this.quickActionsExpanded = false;
                        this.closeStatisticsMenu();
                        this.cancelQuickActionsTimer();
                },
                scheduleQuickActionsCollapse() {
                        this.cancelQuickActionsTimer();
                        this.quickActionsTimer = window.setTimeout(() => {
                                if (!this.quickActionsHovering && !this.statisticsMenuOpen) {
                                        this.collapseQuickActions();
                                }
                        }, 2400);
                },
                cancelQuickActionsTimer() {
                        if (this.quickActionsTimer) {
                                window.clearTimeout(this.quickActionsTimer);
                                this.quickActionsTimer = null;
                        }
                },
                handleQuickActionsMouseEnter() {
                        this.quickActionsHovering = true;
                        this.cancelQuickActionsTimer();
                },
                handleQuickActionsMouseLeave() {
                        this.quickActionsHovering = false;
                        if (this.quickActionsExpanded) {
                                this.scheduleQuickActionsCollapse();
                        }
                },
                handleQuickActionsFocusOut(event) {
                        const next = event?.relatedTarget;
                        if (!next || !event.currentTarget.contains(next)) {
                                this.handleQuickActionsMouseLeave();
                        }
                },
                handleQuickActionsOutside() {
                        this.collapseQuickActions();
                },
                toggleStatisticsMenu() {
                        if (this.statisticsMenuOpen) {
                                this.closeStatisticsMenu();
                                return;
                        }
                        this.statisticsMenuOpen = true;
                        this.cancelQuickActionsTimer();
                },
                closeStatisticsMenu() {
                        if (!this.statisticsMenuOpen) {
                                return;
                        }
                        this.statisticsMenuOpen = false;
                        if (this.quickActionsExpanded) {
                                this.scheduleQuickActionsCollapse();
                        }
                },
                openMetadataPanel() {
                        this.togglePanel(true);
                        this.collapseQuickActions();
                },
                async publishArticle() {
                        const controller = this.ensureController();
                        if (!controller || typeof controller.publish !== 'function') {
                                toast({ message: '编辑器尚未就绪，请稍后重试', type: 'error' });
                                return;
                        }
                        if (this.publishing || this.savingDraft) {
                                return;
                        }
                        this.publishing = true;
                        try {
                                const success = await controller.publish({ silent: false });
                                if (success) {
                                        if (typeof controller.getLatestPublication === 'function') {
                                                this.latestPublication = controller.getLatestPublication() || null;
                                        } else {
                                                this.latestPublication = controller.latestPublication || null;
                                        }
                                        this.refreshStatus();
                                } else {
                                        this.refreshStatus();
                                }
                        } finally {
                                this.publishing = !!controller.publishing;
                        }
                },
                hasPublishedVersion() {
                        if (this.latestPublication && typeof this.latestPublication === 'object') {
                                return true;
                        }
                        const controller = this.ensureController();
                        if (!controller || !controller.postData) {
                                return false;
                        }
                        const status = sanitizeString(controller.postData.Status ?? controller.postData.status ?? '');
                        return status.toLowerCase() === 'published';
                },
                publishButtonLabel() {
                        return this.hasPublishedVersion() ? '更新文章' : '发布文章';
                },
                publishStatusLabel() {
                        if (this.publishing) {
                                return '正在更新线上版本';
                        }
                        return this.hasPublishedVersion() ? '线上版本已就绪' : '当前为草稿';
                },
                publishStatusDescription() {
                        if (this.publishing) {
                                return '正在同步最新内容，请稍候...';
                        }
                        const timestamp = this.latestPublicationTimestamp();
                        if (timestamp) {
                                return `最近发布于 ${timestamp}`;
                        }
                        return '发布后文章会立即同步至线上站点。';
                },
                latestPublicationTimestamp() {
                        const publication = this.latestPublication;
                        let publishedAt = '';
                        if (publication && typeof publication === 'object') {
                                publishedAt = sanitizeString(
                                        publication.PublishedAt ??
                                                publication.published_at ??
                                                publication.publishedAt ??
                                                publication.CreatedAt ??
                                                publication.created_at ??
                                                publication.createdAt ??
                                                '',
                                );
                        }
                        if (!publishedAt) {
                                const controller = this.ensureController();
                                if (controller && controller.postData) {
                                        publishedAt = sanitizeString(
                                                controller.postData.PublishedAt ??
                                                        controller.postData.published_at ??
                                                        controller.postData.publishedAt ??
                                                        '',
                                        );
                                }
                        }
                        if (!publishedAt) {
                                return '';
                        }
                        return this.formatDateTime(publishedAt);
                },
                tryAttachController() {
                        if (this.controller || !window.MilkdownV2 || !window.MilkdownV2.controller) {
                                return;
                        }
                        this.attachController(window.MilkdownV2.controller);
                        const snapshot = typeof this.controller.getPostSnapshot === 'function'
                                ? this.controller.getPostSnapshot()
                                : this.controller.postData;
                        if (snapshot) {
                                this.syncPost(snapshot);
                        }
                },
                ensureController() {
                        if (!this.controller) {
                                this.tryAttachController();
                        }
                        return this.controller;
                },
                attachController(controller) {
                        if (!controller || this.controller === controller) {
                                return;
                        }
                        this.controller = controller;
                        if (typeof controller.getLatestPublication === 'function') {
                                this.latestPublication = controller.getLatestPublication() || null;
                        } else if (controller.latestPublication) {
                                this.latestPublication = controller.latestPublication;
                        }
                        this.applyContentMetrics(controller.contentMetrics);
                        this.updatePostTimestamps(controller.postData);
                        this.syncTagsFromController(controller.postData);
                },
                syncPost(post) {
                        if (!post || typeof post !== 'object') {
                                return;
                        }
                        this.metadata.title = sanitizeString(post.Title ?? post.title ?? '');
                        this.metadata.summary = sanitizeString(post.Summary ?? post.summary ?? '');
                        const coverUrl = sanitizeString(post.CoverURL ?? post.cover_url ?? '');
                        const coverWidth = sanitizeNumber(post.CoverWidth ?? post.cover_width ?? 0);
                        const coverHeight = sanitizeNumber(post.CoverHeight ?? post.cover_height ?? 0);
                        this.metadata.cover = { url: coverUrl, width: coverWidth, height: coverHeight };
                        this.syncTagsFromController(post);
                        this.updatePostTimestamps(post);
                },
                updatePostTimestamps(post) {
                        if (!post || typeof post !== 'object') {
                                this.postCreatedAt = '';
                                this.postUpdatedAt = '';
                                return;
                        }
                        const createdAt = sanitizeString(post.CreatedAt ?? post.created_at ?? post.createdAt ?? '');
                        const updatedAt = sanitizeString(post.UpdatedAt ?? post.updated_at ?? post.updatedAt ?? '');
                        this.postCreatedAt = createdAt;
                        this.postUpdatedAt = updatedAt;
                },
                refreshStatus() {
                        const controller = this.ensureController();
                        if (!controller) {
                                return;
                        }
                        this.autoSaving = !!controller.autoSaving;
                        this.autoSavePending = !!controller.autoSavePending;
                        this.autoSaveError = sanitizeString(controller.autoSaveError || '');
                        this.lastAutoSavedAt = toDate(controller.lastAutoSavedAt);
                        const resolvedId = sanitizeString(controller.postId || 'new').trim();
                        this.postId = resolvedId || 'new';
                        this.savingDraft = !!controller.loading;
                        this.publishing = !!controller.publishing;
                        if (typeof controller.getLatestPublication === 'function') {
                                this.latestPublication = controller.getLatestPublication() || null;
                        } else {
                                this.latestPublication = controller.latestPublication || null;
                        }
                        this.applyContentMetrics(controller.contentMetrics);
                        this.updatePostTimestamps(controller.postData);
                        this.syncTagsFromController(controller.postData);
                },
                applyContentMetrics(metrics) {
                        this.contentMetrics = this.normalizeContentMetrics(metrics);
                },
                normalizeContentMetrics(metrics) {
                        if (!metrics || typeof metrics !== 'object') {
                                return { words: 0, characters: 0, paragraphs: 0 };
                        }
                        const words = Math.max(0, Math.round(sanitizeNumber(metrics.words)));
                        const characters = Math.max(0, Math.round(sanitizeNumber(metrics.characters)));
                        const paragraphs = Math.max(0, Math.round(sanitizeNumber(metrics.paragraphs)));
                        return { words, characters, paragraphs };
                },
                normalizeTag(tag) {
                        if (tag === null || tag === undefined) {
                                return null;
                        }
                        let source = {};
                        if (typeof tag === 'object') {
                                source = { ...tag };
                        } else {
                                const numeric = Number(tag);
                                if (!Number.isFinite(numeric)) {
                                        return null;
                                }
                                source = { id: numeric };
                        }
                        const idCandidate = source.ID ?? source.id ?? source.Id;
                        const id = Number(idCandidate);
                        if (!Number.isFinite(id)) {
                                return null;
                        }
                        const nameCandidate = sanitizeString(source.Name ?? source.name ?? '').trim();
                        const slugCandidate = sanitizeString(source.Slug ?? source.slug ?? '').trim();
                        const name = nameCandidate || `标签 #${id}`;
                        const normalized = {
                                id,
                                ID: id,
                                name,
                                Name: name,
                        };
                        if (slugCandidate) {
                                normalized.slug = slugCandidate;
                                normalized.Slug = slugCandidate;
                        }
                        return normalized;
                },
                normalizeTags(tags) {
                        if (!Array.isArray(tags)) {
                                return [];
                        }
                        const normalized = [];
                        const seen = new Set();
                        for (const item of tags) {
                                const normalizedTag = this.normalizeTag(item);
                                if (!normalizedTag) {
                                        continue;
                                }
                                if (seen.has(normalizedTag.id)) {
                                        continue;
                                }
                                seen.add(normalizedTag.id);
                                normalized.push(normalizedTag);
                        }
                        return normalized;
                },
                tagId(tag) {
                        if (tag && typeof tag === 'object') {
                                const value = tag.id ?? tag.ID ?? tag.Id;
                                const numeric = Number(value);
                                return Number.isFinite(numeric) ? numeric : null;
                        }
                        const numeric = Number(tag);
                        return Number.isFinite(numeric) ? numeric : null;
                },
                resolveTagById(id) {
                        const numeric = this.tagId(id);
                        if (numeric === null) {
                                return null;
                        }
                        const sources = [];
                        if (Array.isArray(this.availableTags)) {
                                sources.push(...this.availableTags);
                        }
                        if (Array.isArray(this.metadata?.tags)) {
                                sources.push(...this.metadata.tags);
                        }
                        for (const candidate of sources) {
                                const candidateId = this.tagId(candidate);
                                if (candidateId === numeric) {
                                        return this.normalizeTag(candidate);
                                }
                        }
                        return this.normalizeTag({ id: numeric });
                },
                syncTagsFromController(post) {
                        const source = post && typeof post === 'object' ? post.Tags ?? post.tags ?? [] : [];
                        const normalized = this.normalizeTags(source);
                        this.metadata.tags = normalized;
                        this.selectedTagIDs = normalized.map(tag => tag.id);
                },
                isTagSelected(tag) {
                        const id = this.tagId(tag);
                        if (id === null) {
                                return false;
                        }
                        return this.selectedTagIDs.some(value => value === id);
                },
                toggleTag(tag) {
                        const id = this.tagId(tag);
                        if (id === null) {
                                return;
                        }
                        if (this.isTagSelected(id)) {
                                this.selectedTagIDs = this.selectedTagIDs.filter(value => value !== id);
                        } else {
                                this.selectedTagIDs = [...this.selectedTagIDs, id];
                        }
                        this.applyTagSelection();
                },
                applyTagSelection() {
                        const uniqueIds = [];
                        for (const value of this.selectedTagIDs) {
                                const id = this.tagId(value);
                                if (id === null || uniqueIds.includes(id)) {
                                        continue;
                                }
                                uniqueIds.push(id);
                        }
                        this.selectedTagIDs = uniqueIds;
                        const selected = uniqueIds
                                .map(id => this.resolveTagById(id))
                                .filter(Boolean)
                                .map(tag => this.normalizeTag(tag));
                        this.metadata.tags = selected;
                        const controller = this.ensureController();
                        if (controller) {
                                if (typeof controller.setTagIds === 'function') {
                                        controller.setTagIds(uniqueIds, this.availableTags);
                                } else if (typeof controller.setTags === 'function') {
                                        const payload = selected.map(tag => ({ ID: tag.id, Name: tag.name, Slug: tag.slug }));
                                        controller.setTags(payload);
                                }
                        }
                },
                formatNumber(value) {
                        if (!this.numberFormatter) {
                                this.numberFormatter = new Intl.NumberFormat('zh-CN');
                        }
                        const sanitized = Math.max(0, Math.round(sanitizeNumber(value)));
                        return this.numberFormatter.format(sanitized);
                },
                paragraphCountLabel() {
                        const paragraphs = Math.max(0, Math.round(sanitizeNumber(this.contentMetrics?.paragraphs)));
                        return this.formatNumber(paragraphs);
                },
                statisticsUpdatedLabel() {
                        const formatted = this.formatDateTime(this.postUpdatedAt);
                        return formatted || 'N/A';
                },
                statisticsCreatedLabel() {
                        const formatted = this.formatDateTime(this.postCreatedAt);
                        return formatted || 'N/A';
                },
                autoSaveIndicatorClasses() {
                        if (this.autoSaveError) {
                                return 'bg-rose-500/80';
                        }
                        if (this.autoSaving) {
                                return 'animate-pulse bg-blue-500/80';
                        }
                        if (this.autoSavePending) {
                                return 'bg-amber-500/80';
                        }
                        return 'bg-emerald-500/80';
                },
                autoSaveLabel() {
                        if (this.autoSaveError) {
                                return this.autoSaveError;
                        }
                        if (this.autoSaving) {
                                return '自动保存中...';
                        }
                        if (this.autoSavePending) {
                                return '存在未保存的更改';
                        }
                        if (this.lastAutoSavedAt) {
                                return `已保存 ${this.relativeTime(this.lastAutoSavedAt)}`;
                        }
                        return '草稿模式已启用';
                },
                autoSaveDescription() {
                        if (this.autoSaveError) {
                                return this.autoSaveError;
                        }
                        if (this.autoSaving) {
                                return '正在写入最新内容，请勿关闭页面。';
                        }
                        if (this.autoSavePending) {
                                return '有新的更改等待保存，稍后将自动提交。';
                        }
                        if (this.lastAutoSavedAt) {
                                return `最近保存于 ${this.formatDateTime(this.lastAutoSavedAt)}。`;
                        }
                        return '系统会定期自动保存草稿，确保写作内容安全。';
                },
                relativeTime(date) {
                        const target = toDate(date);
                        if (!target) {
                                return '';
                        }
                        const now = new Date();
                        const diffSeconds = Math.floor((now.getTime() - target.getTime()) / 1000);
                        if (diffSeconds < 60) {
                                return '刚刚';
                        }
                        if (diffSeconds < 3600) {
                                const minutes = Math.max(1, Math.floor(diffSeconds / 60));
                                return `${minutes} 分钟前`;
                        }
                        const hours = Math.floor(diffSeconds / 3600);
                        if (hours < 24) {
                                return `${hours} 小时前`;
                        }
                        const days = Math.floor(diffSeconds / 86400);
                        return `${days} 天前`;
                },
                formatDateTime(date) {
                        const target = toDate(date);
                        if (!target) {
                                return '';
                        }
                        return target.toLocaleString('zh-CN', {
                                month: 'short',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit',
                        });
                },
                togglePanel(force) {
                        this.panelOpen = typeof force === 'boolean' ? force : !this.panelOpen;
                        if (this.panelOpen) {
                                this.$nextTick(() => {
                                        if (!this.metadata.title && this.$refs.titleInput) {
                                                this.$refs.titleInput.focus();
                                        }
                                });
                        }
                },
                closePanel() {
                        this.panelOpen = false;
                },
                handleTitleChange(value) {
                        const controller = this.ensureController();
                        if (!controller || typeof controller.setTitle !== 'function') {
                                return;
                        }
                        controller.setTitle(value);
                },
                handleSummaryChange(value) {
                        const controller = this.ensureController();
                        if (!controller || typeof controller.setSummary !== 'function') {
                                return;
                        }
                        controller.setSummary(value);
                },
                summaryUsageLabel() {
                        if (!this.summaryUsage) {
                                return '';
                        }
                        const prompt = sanitizeNumber(this.summaryUsage.prompt_tokens ?? this.summaryUsage.promptTokens ?? 0);
                        const completion = sanitizeNumber(this.summaryUsage.completion_tokens ?? this.summaryUsage.completionTokens ?? 0);
                        if (!prompt && !completion) {
                                return '未提供用量信息';
                        }
                        return `Prompt ${prompt} · Completion ${completion}`;
                },
                inlineAIUsageLabel() {
                        const usage = this.inlineAI?.usage;
                        if (!usage) {
                                return '';
                        }
                        const prompt = sanitizeNumber(usage.prompt_tokens ?? usage.promptTokens ?? 0);
                        const completion = sanitizeNumber(usage.completion_tokens ?? usage.completionTokens ?? 0);
                        if (!prompt && !completion) {
                                return '';
                        }
                        return `Prompt ${prompt} · Completion ${completion}`;
                },
                closeInlineAI() {
                        this.inlineAI.open = false;
                        this.inlineAI.loading = false;
                        this.inlineAI.error = '';
                        this.inlineAI.instruction = '';
                        this.inlineAI.suggestion = '';
                        this.inlineAI.usage = null;
                        if (window.MilkdownV2?.inlineAI?.hideToolbar) {
                                try {
                                        window.MilkdownV2.inlineAI.hideToolbar();
                                } catch (error) {
                                        console.warn('[post-editor] 关闭 AI Chat 弹窗时隐藏工具条失败', error);
                                }
                        }
                },
                async runInlineAIChat() {
                        if (this.inlineAI.loading) {
                                return;
                        }
                        const selection = this.inlineAI.selection || {};
                        const selectionText = sanitizeString(selection.normalized || selection.text || '');
                        if (!selectionText.trim()) {
                                toast({ message: '请选择需要改写的段落后再试', type: 'warning' });
                                return;
                        }
                        const instruction = sanitizeString(this.inlineAI.instruction).trim();
                        if (!instruction) {
                                toast({ message: '请输入改写指令', type: 'warning' });
                                return;
                        }
                        this.inlineAI.loading = true;
                        this.inlineAI.error = '';
                        this.inlineAI.suggestion = '';
                        this.inlineAI.usage = null;
                        try {
                                const response = await fetch('/admin/api/posts/chat', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                                selection: selectionText,
                                                instruction,
                                                context: sanitizeString(selection.context || ''),
                                        }),
                                });
                                const data = await response.json();
                                if (!response.ok) {
                                        const message = sanitizeString(data?.error || data?.message || 'AI Chat 请求失败，请稍后重试');
                                        throw new Error(message || 'AI Chat 请求失败，请稍后重试');
                                }
                                const suggestion = sanitizeString(data?.content ?? data?.result ?? '');
                                if (!suggestion.trim()) {
                                        throw new Error('AI Chat 未返回内容，请稍后重试');
                                }
                                this.inlineAI.suggestion = suggestion;
                                this.inlineAI.usage = data?.usage || null;
                                toast({ message: 'AI 已返回改写建议', type: 'success' });
                        } catch (error) {
                                const message = sanitizeString(error?.message || 'AI Chat 请求失败，请稍后重试');
                                this.inlineAI.error = message;
                                toast({ message, type: 'error' });
                        } finally {
                                this.inlineAI.loading = false;
                        }
                },
                applyInlineAISuggestion() {
                        const suggestion = sanitizeString(this.inlineAI.suggestion).trim();
                        if (!suggestion) {
                                this.closeInlineAI();
                                return;
                        }
                        const selection = this.inlineAI.selection || {};
                        const from = selection.from;
                        const to = selection.to;
                        if (!Number.isFinite(from) || !Number.isFinite(to) || from === to) {
                                toast({ message: '无法定位原始选区，请重新选择后再试', type: 'error' });
                                return;
                        }
                        try {
                                const applied = window.MilkdownV2?.inlineAI?.applyChange({
                                        from,
                                        to,
                                        expected: selection.normalized || selection.text || '',
                                        replacement: suggestion,
                                });
                                if (!applied) {
                                        throw new Error('未能应用 AI 改写内容');
                                }
                                this.closeInlineAI();
                                toast({ message: '已应用 AI 改写内容', type: 'success' });
                        } catch (error) {
                                const message = sanitizeString(error?.message || '应用改写内容失败，请稍后重试');
                                toast({ message, type: 'error' });
                        }
                },
                async copyInlineAISuggestion() {
                        const suggestion = sanitizeString(this.inlineAI.suggestion).trim();
                        if (!suggestion) {
                                toast({ message: '暂无可复制的内容', type: 'warning' });
                                return;
                        }
                        if (!navigator?.clipboard?.writeText) {
                                toast({ message: '浏览器不支持快速复制，请手动复制文本', type: 'warning' });
                                return;
                        }
                        try {
                                await navigator.clipboard.writeText(suggestion);
                                toast({ message: '已复制到剪贴板', type: 'success' });
                        } catch (error) {
                                toast({ message: '复制失败，请手动选择文本', type: 'error' });
                        }
                },
                async ensureOptimizationPreviewMount(target) {
                        const preview = this.optimizationPreviews?.[target];
                        if (!preview) {
                                return null;
                        }
                        if (preview.mount) {
                                return preview.mount;
                        }
                        await this.$nextTick();
                        const refName = target === 'optimized' ? 'optimizedContentPreview' : 'optimizationSourcePreview';
                        const mount = this.$refs?.[refName] || null;
                        preview.mount = mount || null;
                        return preview.mount;
                },
                previewPlaceholder(target) {
                        if (target === 'optimized') {
                                return '<p class="text-xs text-emerald-500/70 dark:text-emerald-200/70">等待优化结果...</p>';
                        }
                        return '<p class="text-xs text-slate-400 dark:text-slate-500">暂无内容</p>';
                },
                async destroyOptimizationPreview(target, { keepContainer = false } = {}) {
                        const preview = this.optimizationPreviews?.[target];
                        if (!preview) {
                                return;
                        }
                        const instance = preview.instance;
                        preview.instance = null;
                        preview.ready = false;
                        preview.rendering = null;
                        if (instance && typeof instance.destroy === 'function') {
                                try {
                                        const result = instance.destroy();
                                        if (result && typeof result.then === 'function') {
                                                await result;
                                        }
                                } catch (error) {
                                        console.warn('[post-editor] 预览销毁失败', error);
                                }
                        }
                        if (!keepContainer && preview.mount) {
                                preview.mount.innerHTML = '';
                        }
                },
                async renderOptimizationPreview(target, markdown) {
                        const preview = this.optimizationPreviews?.[target];
                        if (!preview) {
                                return;
                        }
                        if (preview.rendering) {
                                try {
                                        await preview.rendering;
                                } catch (error) {
                                        console.warn('[post-editor] 预览渲染冲突', error);
                                }
                        }
                        const task = (async () => {
                                const mount = await this.ensureOptimizationPreviewMount(target);
                                const value = sanitizeString(markdown).trim();
                                if (!mount) {
                                        return;
                                }
                                if (!value) {
                                        await this.destroyOptimizationPreview(target, { keepContainer: true });
                                        mount.innerHTML = this.previewPlaceholder(target);
                                        preview.ready = false;
                                        return;
                                }

                                const renderFallback = () => {
                                        mount.innerHTML = fallbackMarkdownToHtml(value);
                                        preview.instance = null;
                                        preview.ready = true;
                                };

                                if (!window.MilkdownV2) {
                                        renderFallback();
                                        return;
                                }

                                try {
                                        let viewer = preview.instance;
                                        if (viewer && typeof viewer.setMarkdown === 'function') {
                                                const result = viewer.setMarkdown(value);
                                                if (result && typeof result.then === 'function') {
                                                        await result;
                                                }
                                                preview.ready = true;
                                                return;
                                        }

                                        await this.destroyOptimizationPreview(target, { keepContainer: true });
                                        mount.innerHTML = '';

                                        if (typeof window.MilkdownV2.createReadOnlyViewer === 'function') {
                                                viewer = await window.MilkdownV2.createReadOnlyViewer({
                                                        mount,
                                                        markdown: value,
                                                });
                                        } else {
                                                const CrepeCtor = window.MilkdownV2?.crepe?.constructor;
                                                if (typeof CrepeCtor === 'function') {
                                                        viewer = new CrepeCtor({ root: mount, defaultValue: value || '# ' });
                                                        if (typeof viewer.setReadonly === 'function') {
                                                                viewer.setReadonly(true);
                                                        }
                                                        const created = viewer.create?.();
                                                        if (created && typeof created.then === 'function') {
                                                                await created;
                                                        }
                                                        if (typeof viewer.setMarkdown === 'function') {
                                                                const result = viewer.setMarkdown(value);
                                                                if (result && typeof result.then === 'function') {
                                                                        await result;
                                                                }
                                                        }
                                                }
                                        }

                                        if (!viewer) {
                                                renderFallback();
                                                return;
                                        }

                                        preview.instance = viewer;
                                        preview.ready = true;
                                } catch (error) {
                                        console.warn('[post-editor] 渲染预览失败', error);
                                        await this.destroyOptimizationPreview(target, { keepContainer: true });
                                        renderFallback();
                                }
                        })();
                        preview.rendering = task;
                        try {
                                await task;
                        } finally {
                                if (preview.rendering === task) {
                                        preview.rendering = null;
                                }
                        }
                },
                async optimizeContent() {
                        if (this.optimizingContent) {
                                return;
                        }
                        this.closeStatisticsMenu();
                        const controller = this.ensureController();
                        if (!controller) {
                                toast({ message: '编辑器尚未就绪，请稍后重试', type: 'warning' });
                                return;
                        }
                        const getMarkdown = window.MilkdownV2?.getMarkdown;
                        const sourceContent = typeof getMarkdown === 'function' ? getMarkdown() : sanitizeString(controller.postData?.Content ?? '');
                        const trimmedContent = sourceContent.trim();
                        if (!trimmedContent) {
                                toast({ message: '请先填写文章正文再尝试全文优化', type: 'warning' });
                                return;
                        }
                        const title = this.metadata.title || sanitizeString(controller.postData?.Title ?? '');
                        const wasModalOpen = this.optimizationModal;
                        const previousOptimized = this.optimizedContent;
                        const previousUsage = this.optimizationUsage;
                        const hadResult = typeof previousOptimized === 'string' && previousOptimized.trim().length > 0;
                        this.optimizingContent = true;
                        this.optimizationSource = sourceContent;
                        void this.renderOptimizationPreview('source', sourceContent);
                        this.optimizedContent = '';
                        void this.renderOptimizationPreview('optimized', '');
                        this.optimizationUsage = null;
                        if (!wasModalOpen) {
                                this.optimizationModal = true;
                        }
                        try {
                                const response = await fetch('/admin/api/posts/optimize', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ title, content: trimmedContent })
                                });
                                const data = await response.json();
                                if (!response.ok) {
                                        const message = data?.error || data?.message || '全文优化失败，请稍后重试';
                                        throw new Error(message);
                                }
                                const optimized = sanitizeString(data?.optimized_content ?? data?.optimizedContent ?? '');
                                if (!optimized.trim()) {
                                        throw new Error('AI 全文优化未返回内容，请稍后重试');
                                }
                                this.optimizedContent = optimized;
                                void this.renderOptimizationPreview('optimized', optimized);
                                this.optimizationUsage = data?.usage || null;
                                if (!wasModalOpen) {
                                        this.optimizationModal = true;
                                }
                                toast({ message: '已生成优化提案，请确认内容', type: 'success' });
                        } catch (error) {
                                toast({ message: error?.message || '全文优化失败，请稍后重试', type: 'error' });
                                if (hadResult) {
                                        this.optimizedContent = previousOptimized;
                                        void this.renderOptimizationPreview('optimized', previousOptimized || '');
                                        this.optimizationUsage = previousUsage || null;
                                        this.optimizationModal = wasModalOpen || hadResult;
                                } else if (!wasModalOpen) {
                                        this.optimizationModal = false;
                                }
                        } finally {
                                this.optimizingContent = false;
                        }
                },
                closeOptimizationModal() {
                        this.optimizationModal = false;
                },
                async applyOptimization() {
                        const optimized = sanitizeString(this.optimizedContent);
                        if (!optimized.trim()) {
                                this.closeOptimizationModal();
                                return;
                        }
                        const controller = this.ensureController();
                        let applied = false;
                        const crepe = window.MilkdownV2?.crepe;
                        if (crepe && typeof crepe.setMarkdown === 'function') {
                                try {
                                        const result = crepe.setMarkdown(optimized);
                                        if (result && typeof result.then === 'function') {
                                                applied = await result;
                                        } else if (result !== false) {
                                                applied = true;
                                        }
                                } catch (error) {
                                        console.warn('[post-editor] crepe.setMarkdown 调用失败', error);
                                }
                        }
                        if (controller) {
                                controller.postData.Content = optimized;
                                controller.postData.content = optimized;
                                controller.currentContent = optimized;
                                if (typeof controller.markDirty === 'function') {
                                        controller.markDirty();
                                } else {
                                        controller.autoSavePending = true;
                                        controller.autoSaveError = '';
                                }
                                if (typeof controller.notifyPostChange === 'function') {
                                        controller.notifyPostChange('content');
                                }
                        }
                        this.optimizationSource = optimized;
                        void this.renderOptimizationPreview('source', optimized);
                        if (!applied) {
                                toast({ message: '优化内容已生成，请确认编辑器中的展示是否同步', type: 'info' });
                        } else {
                                toast({ message: '已替换为优化后的正文', type: 'success' });
                        }
                        this.closeOptimizationModal();
                },
                async generateSummary() {
                        if (this.generatingSummary) {
                                return;
                        }
                        const controller = this.ensureController();
                        if (!controller) {
                                toast({ message: '编辑器尚未就绪，请稍后重试', type: 'warning' });
                                return;
                        }
                        const getMarkdown = window.MilkdownV2?.getMarkdown;
                        const content = typeof getMarkdown === 'function' ? getMarkdown() : sanitizeString(controller.postData?.Content ?? '');
                        const title = this.metadata.title || sanitizeString(controller.postData?.Title ?? '');
                        if (!title && !content) {
                                toast({ message: '请先填写标题或正文后再生成摘要', type: 'warning' });
                                return;
                        }
                        this.generatingSummary = true;
                        this.summaryUsage = null;
                        try {
                                const response = await fetch('/admin/api/posts/summary', {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({ title, content }),
                                });
                                const data = await response.json();
                                if (!response.ok) {
                                        const message = data?.error || data?.message || '生成摘要失败，请稍后重试';
                                        throw new Error(message);
                                }
                                const summary = sanitizeString(data.summary);
                                if (!summary.trim()) {
                                        throw new Error('AI 摘要服务未返回内容，请稍后重试');
                                }
                                this.applySummary(summary, data.usage || null);
                                toast({ message: '已生成 AI 摘要，请确认内容', type: 'success' });
                        } catch (error) {
                                toast({ message: error?.message || '生成摘要失败，请稍后重试', type: 'error' });
                        } finally {
                                this.generatingSummary = false;
                        }
                },
                applySummary(summary, usage) {
                        this.metadata.summary = summary;
                        this.summaryUsage = usage || null;
                        const controller = this.ensureController();
                        if (controller && typeof controller.setSummary === 'function') {
                                controller.setSummary(summary);
                        }
                },
                openCoverPicker() {
                        if (this.$refs.coverInput) {
                                this.$refs.coverInput.click();
                        }
                },
                handleCoverFile(event) {
                        const input = event?.target;
                        const [file] = input?.files || [];
                        if (!file) {
                                return;
                        }
                        if (typeof window.Cropper === 'undefined') {
                                toast({ message: '封面裁剪模块尚未加载，请刷新页面后重试', type: 'error' });
                                return;
                        }
                        this.resetCropper();
                        this.coverSource = URL.createObjectURL(file);
                        this.coverModal = true;
                        this.initCropperWhenReady();
                        if (input) {
                                input.value = '';
                        }
                },
                initCropperWhenReady() {
                        this.$nextTick(() => {
                                const image = this.$refs.cropperImage;
                                if (!image || typeof window.Cropper === 'undefined') {
                                        return;
                                }
                                this.cropper = new window.Cropper(image, {
                                        aspectRatio: this.aspectValue(),
                                        viewMode: 2,
                                        autoCropArea: 1,
                                        background: false,
                                        responsive: true,
                                        movable: true,
                                        zoomable: true,
                                        ready: () => {
                                                this.adjustCropBox();
                                        },
                                });
                        });
                },
                adjustCropBox() {
                        if (!this.cropper) {
                                return;
                        }
                        this.cropper.setAspectRatio(this.aspectValue());
                },
                confirmCrop() {
                        if (!this.cropper || this.uploadingCover) {
                                return;
                        }
                        this.uploadingCover = true;
                        this.cropper.getCroppedCanvas({ imageSmoothingQuality: 'high' }).toBlob(async blob => {
                                if (!blob) {
                                        this.uploadingCover = false;
                                        toast({ message: '生成裁剪图片失败，请重试', type: 'error' });
                                        return;
                                }
                                try {
                                        await this.uploadCroppedImage(blob);
                                        toast({ message: '封面已更新', type: 'success' });
                                } catch (error) {
                                        toast({ message: error?.message || '封面上传失败，请稍后重试', type: 'error' });
                                } finally {
                                        this.uploadingCover = false;
                                }
                        }, 'image/png');
                },
                async uploadCroppedImage(blob) {
                        const formData = new FormData();
                        formData.append('image', blob, `cover-${Date.now()}.png`);
                        const response = await fetch('/admin/api/upload/image', {
                                method: 'POST',
                                body: formData,
                        });
                        const data = await response.json();
                        if (!response.ok || data?.success !== 1) {
                                const message = data?.error || data?.message || '封面上传失败';
                                throw new Error(message);
                        }
                        const url = sanitizeString(data?.data?.url || data?.data?.filePath || '');
                        const width = sanitizeNumber(data?.data?.width || data?.data?.Width || 0);
                        const height = sanitizeNumber(data?.data?.height || data?.data?.Height || 0);
                        if (!url) {
                                throw new Error('封面上传成功但未返回访问地址');
                        }
                        this.applyCover(url, width, height);
                        this.closeCropper();
                },
                applyCover(url, width, height) {
                        this.metadata.cover = { url, width, height };
                        const controller = this.ensureController();
                        if (controller && typeof controller.setCover === 'function') {
                                controller.setCover({ url, width, height });
                        }
                },
                removeCover() {
                        this.metadata.cover = { url: '', width: 0, height: 0 };
                        const controller = this.ensureController();
                        if (controller) {
                                if (typeof controller.clearCover === 'function') {
                                        controller.clearCover();
                                } else if (typeof controller.setCover === 'function') {
                                        controller.setCover({ url: '', width: 0, height: 0 });
                                }
                        }
                },
                reCropCover() {
                        const { url, width, height } = this.metadata.cover || {};
                        if (!url) {
                                return;
                        }
                        try {
                                const target = new URL(url, window.location.origin);
                                if (target.origin !== window.location.origin) {
                                        toast({ message: '该封面来源于外部链接，请重新上传新的封面', type: 'warning' });
                                        return;
                                }
                        } catch (error) {
                                return;
                        }
                        if (typeof window.Cropper === 'undefined') {
                                toast({ message: '封面裁剪模块尚未加载，请刷新页面后重试', type: 'error' });
                                return;
                        }
                        if (width > 0 && height > 0) {
                                this.cropAspect = width >= height ? '16:9' : '3:4';
                        }
                        this.resetCropper();
                        this.coverSource = url;
                        this.coverModal = true;
                        this.initCropperWhenReady();
                },
                closeCropper() {
                        this.resetCropper();
                        if (this.coverSource && this.coverSource.startsWith('blob:')) {
                                URL.revokeObjectURL(this.coverSource);
                        }
                        this.coverModal = false;
                        this.coverSource = '';
                },
                resetCropper() {
                        if (this.cropper) {
                                this.cropper.destroy();
                                this.cropper = null;
                        }
                },
                setAspect(ratio) {
                        this.cropAspect = ratio;
                        if (this.cropper) {
                                this.cropper.setAspectRatio(this.aspectValue());
                        }
                },
                aspectValue() {
                        return this.cropAspect === '3:4' ? 3 / 4 : 16 / 9;
                },
                formatCoverSize() {
                        const { width, height } = this.metadata.cover || {};
                        if (!width || !height) {
                                return '未知尺寸';
                        }
                        return `${width} × ${height} px`;
                },
                async triggerSave() {
                        if (this.savingDraft) {
                                return;
                        }
                        this.collapseQuickActions();
                        if (!window.MilkdownV2 || typeof window.MilkdownV2.saveDraft !== 'function') {
                                toast({ message: '保存功能暂不可用，请稍后重试', type: 'error' });
                                return;
                        }
                        this.savingDraft = true;
                        try {
                                await window.MilkdownV2.saveDraft({
                                        redirectOnCreate: false,
                                        silent: false,
                                        notifyOnSilent: true,
                                        useLoadingState: true,
                                });
                        } catch (error) {
                                toast({ message: error?.message || '保存失败，请稍后重试', type: 'error' });
                        } finally {
                                this.savingDraft = false;
                                this.refreshStatus();
                        }
                },
                formatCoverSizeLegacy() {
                        return this.formatCoverSize();
                },
        }));
});
</script>
<script type="module" src="/static/dist/assets/milkdown_v2.js"></script>
{{end}}
