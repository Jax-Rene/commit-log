{{template "base" .}} {{define "content"}} {{$content := ""}} {{if .post}} {{if
.post.Content}} {{$content = .post.Content}} {{end}} {{end}} {{$initial := dict
"content" $content "post" .post "latestPublication" .latestPublication "allTags"
.allTags "tagError" .tagError}}

<style>
    html,
    body {
        min-height: 100%;
        background-color: #fdfcff;
        color: #0f172a; /* 确保正文采用 text-slate-900 色值 */
    }

    body.milkdown-immersive {
        background-color: #fdfcff;
        overflow-x: hidden;
    }

    body.milkdown-immersive header,
    body.milkdown-immersive footer {
        display: none !important;
    }

    body.milkdown-immersive main {
        max-width: 100vw !important;
        width: 100vw !important;
        padding: 0 !important;
        min-height: 100vh;
    }

    body.milkdown-immersive main > * {
        margin: 0;
        min-height: 100vh;
    }

    .milkdown-immersive-shell .milkdown a,
    .milkdown-preview .milkdown a {
        text-decoration: none;
    }

    .milkdown-immersive-shell .milkdown a:hover,
    .milkdown-preview .milkdown a:hover {
        text-decoration: underline;
        text-underline-offset: 3px;
    }

    .milkdown-immersive-shell .milkdown strong,
    .milkdown-immersive-shell .milkdown b,
    .milkdown-preview .milkdown strong,
    .milkdown-preview .milkdown b,
    #milkdown-app > div > .ProseMirror strong,
    #milkdown-app > div > .ProseMirror b {
        color: #16a34a;
        font-weight: 800;
    }

    .milkdown-immersive-shell .milkdown :is(h1, h2, h3, h4, h5, h6) strong,
    .milkdown-immersive-shell .milkdown :is(h1, h2, h3, h4, h5, h6) b,
    .milkdown-preview .milkdown :is(h1, h2, h3, h4, h5, h6) strong,
    .milkdown-preview .milkdown :is(h1, h2, h3, h4, h5, h6) b,
    #milkdown-app > div > .ProseMirror :is(h1, h2, h3, h4, h5, h6) strong,
    #milkdown-app > div > .ProseMirror :is(h1, h2, h3, h4, h5, h6) b {
        color: inherit;
    }

    .milkdown-immersive-shell .milkdown .callout-block,
    .milkdown-preview .milkdown .callout-block,
    #milkdown-app > div > .ProseMirror .callout-block {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 1.25rem;
        padding: 1.5rem 1.75rem;
        border-radius: 10px;
        background-color: #f9f9f9;
        margin: 1.5rem 0;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-wrapper,
    .milkdown-preview .milkdown .callout-emoji-wrapper {
        position: relative;
        align-self: flex-start;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-button,
    .milkdown-preview .milkdown .callout-emoji-button {
        font-size: 20px;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-button:hover,
    .milkdown-preview .milkdown .callout-emoji-button:hover {
        background-color: #f1f5f9;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-button:focus-visible,
    .milkdown-preview .milkdown .callout-emoji-button:focus-visible {
        outline: 2px solid rgba(59, 130, 246, 0.45);
        outline-offset: 3px;
    }

    .milkdown-immersive-shell
        .milkdown
        .callout-emoji-button[data-empty="true"],
    .milkdown-preview .milkdown .callout-emoji-button[data-empty="true"] {
        color: #94a3b8;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-panel,
    .milkdown-preview .milkdown .callout-emoji-panel {
        position: absolute;
        top: 48px;
        left: 0;
        background-color: #ffffff;
        border: 1px solid #e2e8f0;
        border-radius: 12px;
        padding: 8px;
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.12);
        display: none;
        z-index: 20;
        min-width: 210px;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-panel[data-open="true"],
    .milkdown-preview .milkdown .callout-emoji-panel[data-open="true"] {
        display: block;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-grid,
    .milkdown-preview .milkdown .callout-emoji-grid {
        display: grid;
        grid-template-columns: repeat(6, minmax(0, 1fr));
        gap: 6px;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-option,
    .milkdown-preview .milkdown .callout-emoji-option {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: none;
        background-color: transparent;
        cursor: pointer;
        font-size: 18px;
        line-height: 1;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-option:hover,
    .milkdown-preview .milkdown .callout-emoji-option:hover {
        background-color: #f1f5f9;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-remove,
    .milkdown-preview .milkdown .callout-emoji-remove {
        margin-top: 8px;
        width: 100%;
        border: 1px solid #e2e8f0;
        border-radius: 8px;
        background-color: #f8fafc;
        color: #64748b;
        padding: 6px 10px;
        font-size: 12px;
        font-weight: 600;
        cursor: pointer;
    }

    .milkdown-immersive-shell .milkdown .callout-emoji-remove:hover,
    .milkdown-preview .milkdown .callout-emoji-remove:hover {
        background-color: #f1f5f9;
    }

    .milkdown-immersive-shell .milkdown .callout-content > *:first-child,
    .milkdown-preview .milkdown .callout-content > *:first-child {
        margin-top: 0;
    }

    .milkdown-immersive-shell .milkdown .callout-content > * + *,
    .milkdown-preview .milkdown .callout-content > * + * {
        margin-top: 0.75rem;
    }

    /* 全局隐藏滚动条但保留滚动功能 */
    html,
    body,
    main,
    .milkdown-immersive-wrapper,
    .milkdown-immersive-shell .milkdown {
        scrollbar-width: none;
    }
    html::-webkit-scrollbar,
    body::-webkit-scrollbar,
    main::-webkit-scrollbar,
    .milkdown-immersive-wrapper::-webkit-scrollbar,
    .milkdown-immersive-shell .milkdown::-webkit-scrollbar {
        display: none;
    }

    .milkdown-immersive-shell {
        position: relative;
        display: flex;
        flex-direction: column;
        min-height: 100vh;
        overflow: visible;
    }

    .milkdown-immersive-wrapper {
        flex: 1 1 auto;
        display: block;
        overflow: visible;
        min-height: 100vh;
    }

    .milkdown-immersive-container {
        flex: 1 1 auto;
        display: grid;
        align-items: stretch;
        min-height: 100vh;
    }

    .milkdown-immersive-shell .milkdown {
        flex: 1 1 auto;
        min-height: 100vh;
        overflow-x: hidden;
        overflow-y: auto;
        --crepe-color-background: #fdfcff;
        background-color: #fdfcff;
        color: #0f172a; /* 覆写编辑器正文默认前景色 */
    }

    .milkdown-preview .milkdown {
        background-color: transparent;
        box-shadow: none;
    }

    .milkdown-preview .milkdown .ProseMirror {
        padding: 0;
    }

    #milkdown-app > div > .ProseMirror {
        padding: 1rem 1rem 1.5rem;
    }

    /* 调整编辑器与预览内 blockquote 左侧内边距 */
    .milkdown-immersive-shell .milkdown blockquote,
    .milkdown-preview .milkdown blockquote,
    #milkdown-app > div > .ProseMirror blockquote {
        padding-left: 20px !important;
    }

    @media (min-width: 768px) {
        #milkdown-app > div > .ProseMirror {
            padding: 1rem 1.25rem 1.75rem;
        }
    }

    [data-editor-toc-content] h1,
    [data-editor-toc-content] h2,
    [data-editor-toc-content] h3 {
        scroll-margin-top: 6.5rem;
    }

    [data-editor-toc-card] nav::before {
        content: "";
        position: absolute;
        top: 0.75rem;
        bottom: 0.75rem;
        left: 0.75rem;
        width: 1px;
        background: linear-gradient(
            180deg,
            rgba(148, 163, 184, 0.28),
            rgba(148, 163, 184, 0.08)
        );
    }

    [data-editor-toc-card] ul {
        list-style: none;
        margin: 0;
        padding: 0;
    }

    [data-editor-toc-card] .toc-item {
        position: relative;
    }

    /* 隐藏 Slash 菜单内部滚动条，保持可滚动 */
    .milkdown-slash-menu .menu-groups {
        scrollbar-width: none; /* Firefox */
    }
    .milkdown-slash-menu .menu-groups::-webkit-scrollbar {
        display: none; /* Chrome/Safari */
    }

    .milkdown-immersive-shell .milkdown .milkdown-slash-menu {
        max-height: min(420px, calc(100vh - 5rem));
        overflow: auto;
    }

    [data-editor-toc-card] .toc-link {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        min-width: 0;
        font-size: 0.875rem;
        line-height: 1.45;
        color: rgba(71, 85, 105, 0.95);
        text-decoration: none;
        transition: color 0.2s ease;
    }

    [data-editor-toc-card] .toc-link:focus-visible {
        outline: 2px solid rgba(59, 130, 246, 0.4);
        outline-offset: 4px;
        border-radius: 12px;
    }

    [data-editor-toc-card] .toc-tick {
        height: 2px;
        width: 14px;
        border-radius: 9999px;
        flex-shrink: 0;
        background-color: rgba(148, 163, 184, 0.5);
        transition:
            background-color 0.2s ease,
            width 0.2s ease;
    }

    [data-editor-toc-card] .toc-text {
        display: block;
        flex: 1 1 auto;
        min-width: 0;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        max-width: 100%;
        color: rgba(30, 41, 59, 0.82);
    }

    [data-editor-toc-card] .toc-item[data-level="2"] .toc-text {
        margin-left: 0.75rem;
    }

    [data-editor-toc-card] .toc-item[data-level="3"] .toc-text {
        margin-left: 1.5rem;
    }

    [data-editor-toc-card] .toc-item.is-active .toc-link {
        color: rgb(30, 64, 175);
        font-weight: 600;
    }

    [data-editor-toc-card] .toc-item.is-active .toc-tick {
        width: 18px;
        background-color: rgb(59, 130, 246);
    }

    @media (prefers-color-scheme: dark) {
        body {
            background-color: #020617;
            color: #e2e8f0; /* 匹配 dark:text-slate-100 */
        }

        body.milkdown-immersive {
            background-color: #020617;
        }

        .milkdown-immersive-shell .milkdown {
            --crepe-color-background: #020617;
            --crepe-color-on-background: #e2e8f0;
            --crepe-color-surface: #0f172a;
            --crepe-color-surface-low: #0b1629;
            --crepe-color-on-surface: #e2e8f0;
            --crepe-color-on-surface-variant: #cbd5e1;
            --crepe-color-outline: #1f2f46;
            --crepe-color-primary: #7dd3fc;
            --crepe-color-secondary: #13203c;
            --crepe-color-on-secondary: #e0f2fe;
            --crepe-color-inverse: #e2e8f0;
            --crepe-color-on-inverse: #020617;
            --crepe-color-inline-code: #fbbf24;
            --crepe-color-error: #fda4af;
            --crepe-color-hover: rgba(255, 255, 255, 0.06);
            --crepe-color-selected: rgba(125, 211, 252, 0.22);
            --crepe-color-inline-area: #11233f;
            --crepe-shadow-1:
                0 18px 48px rgba(0, 0, 0, 0.5), 0 8px 20px rgba(0, 0, 0, 0.35);
            --crepe-shadow-2:
                0 24px 64px rgba(0, 0, 0, 0.55), 0 12px 24px rgba(0, 0, 0, 0.35);
            background-color: #020617;
            color: #e2e8f0; /* 深色模式下提升文字可读性 */
        }

        .milkdown-immersive-shell .milkdown .callout-block,
        .milkdown-preview .milkdown .callout-block,
        #milkdown-app > div > .ProseMirror .callout-block {
            background-color: #101826;
        }

        .milkdown-immersive-shell .milkdown .callout-emoji-button,
        .milkdown-preview .milkdown .callout-emoji-button {
            background-color: #0b1629;
            border-color: #1f2f46;
            color: #e2e8f0;
        }

        .milkdown-immersive-shell .milkdown .callout-emoji-button:hover,
        .milkdown-preview .milkdown .callout-emoji-button:hover {
            background-color: rgba(255, 255, 255, 0.06);
        }

        .milkdown-immersive-shell .milkdown .callout-emoji-panel,
        .milkdown-preview .milkdown .callout-emoji-panel {
            background-color: #0b1629;
            border-color: #1f2f46;
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.4);
        }

        .milkdown-immersive-shell .milkdown .callout-emoji-option:hover,
        .milkdown-preview .milkdown .callout-emoji-option:hover {
            background-color: rgba(255, 255, 255, 0.08);
        }

        .milkdown-immersive-shell .milkdown .callout-emoji-remove,
        .milkdown-preview .milkdown .callout-emoji-remove {
            background-color: #0f172a;
            border-color: #1f2f46;
            color: #cbd5e1;
        }

        .milkdown-immersive-shell .milkdown .callout-emoji-remove:hover,
        .milkdown-preview .milkdown .callout-emoji-remove:hover {
            background-color: rgba(255, 255, 255, 0.08);
        }

        .milkdown-immersive-shell .milkdown .ProseMirror pre {
            border: 1px solid #1f2f46;
        }

        .milkdown-immersive-shell .milkdown .milkdown-code-block {
            border: 1px solid #1f2f46;
            box-shadow: none;
        }

        .milkdown-immersive-shell .milkdown .milkdown-code-block .cm-editor,
        .milkdown-immersive-shell .milkdown .milkdown-code-block .cm-scroller,
        .milkdown-immersive-shell .milkdown .milkdown-code-block .cm-content,
        .milkdown-immersive-shell .milkdown .milkdown-code-block .cm-line {
            color: #e2e8f0;
        }

        .milkdown-immersive-shell .milkdown .milkdown-code-block .cm-gutters {
            color: #94a3b8;
            border-right-color: #1f2f46;
        }

        .milkdown-immersive-shell
            .milkdown
            .milkdown-code-block
            .cm-activeLineGutter,
        .milkdown-immersive-shell
            .milkdown
            .milkdown-code-block
            .cm-activeLine {
            background-color: rgba(125, 211, 252, 0.12);
        }

        .milkdown-immersive-shell
            .milkdown
            .milkdown-code-block
            .cm-selectionBackground {
            background-color: rgba(125, 211, 252, 0.2) !important;
        }

        .milkdown-immersive-shell .milkdown .milkdown-code-block .cm-cursor {
            border-left-color: #7dd3fc;
        }

        .milkdown-immersive-shell .milkdown .katex {
            color: #e2e8f0;
        }

        .milkdown-immersive-shell
            .milkdown
            .milkdown-toolbar
            .toolbar-item
            svg {
            color: rgba(226, 232, 240, 0.92);
            fill: rgba(226, 232, 240, 0.92);
        }

        .milkdown-immersive-shell
            .milkdown
            .milkdown-toolbar
            .toolbar-item.active
            svg {
            color: #7dd3fc;
            fill: #7dd3fc;
        }

        .milkdown-preview .milkdown {
            background-color: transparent;
        }

        [data-editor-toc-card] nav::before {
            background: linear-gradient(
                180deg,
                rgba(71, 85, 105, 0.55),
                rgba(71, 85, 105, 0.18)
            );
        }

        [data-editor-toc-card] .toc-link {
            color: rgba(148, 163, 184, 0.92);
        }

        [data-editor-toc-card] .toc-text {
            display: block;
            color: rgba(226, 232, 240, 0.86);
        }

        [data-editor-toc-card] .toc-link:focus-visible {
            outline-color: rgba(148, 197, 255, 0.55);
        }

        [data-editor-toc-card] .toc-tick {
            background-color: rgba(148, 163, 184, 0.38);
        }

        [data-editor-toc-card] .toc-item.is-active .toc-link {
            color: rgba(191, 219, 254, 0.95);
        }

        [data-editor-toc-card] .toc-item.is-active .toc-tick {
            background-color: rgba(191, 219, 254, 0.95);
        }
    }
</style>

<div
    class="milkdown-immersive-shell"
    x-data="postEditorShell()"
    x-init="init()"
    x-cloak
>
    <div class="milkdown-immersive-wrapper" data-editor-scroll>
        <div
            class="milkdown-immersive-container mx-auto grid w-full max-w-screen-xl grid-cols-1 gap-10 px-3 pt-6 pb-8 sm:px-5 sm:pt-8 sm:pb-10 md:px-12 md:pt-10 md:pb-24 lg:px-16 xl:grid-cols-[minmax(0,1fr)_18rem] xl:items-stretch xl:gap-16 xl:px-20 2xl:max-w-screen-2xl 2xl:px-24"
        >
            <div class="flex min-h-full flex-col">
                <div
                    id="milkdown-app"
                    class="milkdown"
                    data-editor-toc-content
                ></div>
            </div>
            <aside class="hidden xl:flex xl:flex-col">
                <div
                    data-editor-toc-card
                    class="sticky top-24 hidden w-full max-w-[18rem] rounded-3xl bg-transparent p-5"
                >
                    <div
                        class="text-[11px] font-semibold uppercase tracking-[0.28em] text-slate-400 dark:text-slate-500"
                    >
                        CONTENTS
                    </div>
                    <nav class="relative mt-5" aria-label="Table of contents">
                        <ul class="space-y-3" data-toc-list></ul>
                    </nav>
                </div>
            </aside>
        </div>
    </div>

    <div
        class="pointer-events-none fixed bottom-6 right-6 z-40 flex flex-col items-end gap-3"
    >
        <div
            class="pointer-events-auto flex flex-col items-end gap-3"
            @mouseenter="handleQuickActionsMouseEnter()"
            @mouseleave="handleQuickActionsMouseLeave()"
            @focusin="handleQuickActionsMouseEnter()"
            @focusout="handleQuickActionsFocusOut($event)"
            @click.outside="handleQuickActionsOutside()"
        >
            <div
                x-show="quickActionsExpanded"
                x-transition.opacity
                x-transition.scale.origin-bottom-right
                class="w-72 max-w-[calc(100vw-48px)] rounded-2xl border border-slate-200 bg-white/95 p-4 text-sm shadow-xl shadow-slate-200/80 backdrop-blur supports-backdrop-blur:bg-white/80 dark:border-slate-700 dark:bg-slate-900/90 dark:shadow-slate-900/40"
            >
                <div class="flex items-center justify-between">
                    <div
                        class="flex items-center gap-2 text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500"
                    >
                        <span>写作助手</span>
                        <span
                            class="h-1.5 w-1.5 rounded-full"
                            :class="autoSaveIndicatorClasses()"
                        ></span>
                    </div>
                    <button
                        type="button"
                        class="rounded-full p-1 text-slate-400 transition hover:text-slate-600 dark:text-slate-500 dark:hover:text-slate-300"
                        @click="collapseQuickActions()"
                        aria-label="收起工具面板"
                    >
                        <svg
                            class="h-4 w-4"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="1.5"
                                d="M6 12h12"
                            ></path>
                        </svg>
                    </button>
                </div>
                <p
                    class="mt-2 text-xs leading-relaxed text-slate-500 dark:text-slate-400"
                    x-text="autoSaveLabel()"
                ></p>
                <div class="mt-3 grid gap-2">
                    <button
                        type="button"
                        class="inline-flex items-center justify-center gap-2 rounded-xl bg-blue-600 px-4 py-2 font-medium text-white transition hover:bg-blue-500 disabled:cursor-not-allowed disabled:bg-slate-300 dark:hover:bg-blue-500/90 dark:disabled:bg-slate-700/70"
                        @click="triggerSave()"
                        :disabled="savingDraft"
                    >
                        <svg
                            class="h-4 w-4"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="1.5"
                                d="M16.5 3.75h-9A2.25 2.25 0 0 0 5.25 6v12A2.25 2.25 0 0 0 7.5 20.25h9A2.25 2.25 0 0 0 18.75 18V6A2.25 2.25 0 0 0 16.5 3.75Z"
                            ></path>
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="1.5"
                                d="M9.75 7.5h4.5M9.75 12h4.5m-4.5 4.5h2.25"
                            ></path>
                        </svg>
                        <span x-show="!savingDraft">保存草稿</span>
                        <span x-show="savingDraft">保存中...</span>
                    </button>
                    <div
                        class="rounded-xl border border-emerald-200 bg-emerald-50/70 p-3 text-xs text-slate-600 shadow-sm dark:border-emerald-500/40 dark:bg-emerald-500/10 dark:text-slate-200"
                    >
                        <div class="flex items-start justify-between gap-3">
                            <div>
                                <p
                                    class="text-[11px] font-semibold uppercase tracking-wide text-emerald-600 dark:text-emerald-300"
                                >
                                    发布状态
                                </p>
                                <p
                                    class="mt-1 text-sm font-medium text-slate-700 dark:text-slate-100"
                                    x-text="publishStatusLabel()"
                                ></p>
                            </div>
                            <button
                                type="button"
                                class="inline-flex items-center gap-2 rounded-lg bg-emerald-500 px-3 py-1.5 text-xs font-semibold text-white transition hover:bg-emerald-500/90 disabled:cursor-not-allowed disabled:bg-emerald-300 dark:bg-emerald-400 dark:hover:bg-emerald-300/80 dark:disabled:bg-emerald-600/60"
                                @click="publishArticle()"
                                :disabled="publishing || savingDraft"
                            >
                                <svg
                                    class="h-3.5 w-3.5"
                                    viewBox="0 0 24 24"
                                    fill="none"
                                    stroke="currentColor"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="1.5"
                                        d="M12 5v14M7 10l5-5 5 5"
                                    ></path>
                                </svg>
                                <span
                                    x-show="!publishing"
                                    x-text="publishButtonLabel()"
                                ></span>
                                <span x-show="publishing">发布中...</span>
                            </button>
                        </div>
                        <p
                            class="mt-2 leading-relaxed text-[11px] text-slate-500 dark:text-slate-400"
                            x-text="publishStatusDescription()"
                        ></p>
                        <button
                            type="button"
                            class="mt-3 inline-flex w-full items-center justify-center gap-2 rounded-lg border border-rose-200 px-3 py-2 text-sm font-semibold text-rose-600 transition hover:border-rose-300 hover:bg-rose-50 disabled:cursor-not-allowed disabled:border-rose-100 disabled:text-rose-300 dark:border-rose-500/60 dark:text-rose-200 dark:hover:border-rose-400/70 dark:hover:bg-rose-500/10 dark:disabled:border-rose-900/60 dark:disabled:text-rose-800/60"
                            @click="confirmResetToPublication()"
                            :disabled="resettingFromPublication || savingDraft || publishing || !hasPublishedVersion()"
                        >
                            <svg
                                class="h-4 w-4"
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                            >
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="1.5"
                                    d="M9 15 4 12l5-3"
                                ></path>
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="1.5"
                                    d="M5 12h9a4 4 0 1 1 0 8H9"
                                ></path>
                            </svg>
                            <span x-show="!resettingFromPublication"
                                >重置为线上版</span
                            >
                            <span x-show="resettingFromPublication"
                                >重置中...</span
                            >
                        </button>
                        <p
                            x-show="!hasPublishedVersion()"
                            class="mt-1 text-[11px] text-slate-400 dark:text-slate-500"
                        >
                            暂无线上版本，发布后可用该操作。
                        </p>
                    </div>
                    <button
                        type="button"
                        class="inline-flex items-center justify-center gap-2 rounded-xl bg-emerald-500 px-4 py-2 font-semibold text-white transition hover:bg-emerald-500/90 disabled:cursor-not-allowed disabled:bg-emerald-300 dark:bg-emerald-500/90 dark:hover:bg-emerald-400 dark:disabled:bg-emerald-700/70"
                        @click="optimizeContent()"
                        :disabled="optimizingContent"
                    >
                        <svg
                            class="h-4 w-4 text-emerald-100 transition-colors dark:text-emerald-200"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="1.5"
                                d="M12 3v2.25M19.5 12H21M3 12h2.25M16.95 7.05l1.59-1.59M5.46 18.54l1.59-1.59M7.05 7.05 5.46 5.46M18.54 18.54l-1.59-1.59M12 8.25a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Z"
                            ></path>
                        </svg>
                        <span x-show="!optimizingContent">AI 全文优化</span>
                        <span x-show="optimizingContent">优化中...</span>
                    </button>
                    <div class="relative">
                        <button
                            type="button"
                            class="inline-flex w-full items-center justify-center gap-2 rounded-xl border border-slate-200 px-4 py-2 font-medium text-slate-600 transition hover:border-blue-200 hover:text-blue-600 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/60 dark:hover:text-blue-200"
                            @click="toggleStatisticsMenu()"
                            :aria-expanded="statisticsMenuOpen"
                        >
                            <svg
                                class="h-4 w-4"
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                            >
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="1.5"
                                    d="M4.5 19.5h15M7.5 15l3-4.5 3 3 3-4.5"
                                ></path>
                            </svg>
                            <span>Statistics</span>
                            <svg
                                class="h-3.5 w-3.5 text-slate-400 transition-transform dark:text-slate-500"
                                :class="statisticsMenuOpen ? 'rotate-180' : ''"
                                viewBox="0 0 20 20"
                                fill="none"
                                stroke="currentColor"
                            >
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="1.5"
                                    d="M6 8l4 4 4-4"
                                ></path>
                            </svg>
                        </button>
                        <div
                            x-cloak
                            x-show="statisticsMenuOpen"
                            x-transition.origin-top-right
                            class="absolute right-0 top-full z-10 mt-2 w-64 rounded-xl border border-slate-200 bg-white/95 p-3 text-xs text-slate-500 shadow-xl shadow-slate-200/80 backdrop-blur supports-backdrop-blur:bg-white/80 dark:border-slate-700 dark:bg-slate-900/95 dark:text-slate-400"
                        >
                            <p
                                class="mb-2 text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500"
                            >
                                Statistics
                            </p>
                            <ul class="space-y-2">
                                <li class="flex items-center justify-between">
                                    <span
                                        class="font-medium text-slate-600 dark:text-slate-200"
                                        >Words</span
                                    >
                                    <span
                                        class="text-sm font-semibold text-slate-900 dark:text-slate-100"
                                        x-text="formatNumber(contentMetrics?.words)"
                                    ></span>
                                </li>
                                <li class="flex items-center justify-between">
                                    <span
                                        class="font-medium text-slate-600 dark:text-slate-200"
                                        >Characters</span
                                    >
                                    <span
                                        class="text-sm font-semibold text-slate-900 dark:text-slate-100"
                                        x-text="formatNumber(contentMetrics?.characters)"
                                    ></span>
                                </li>
                                <li class="flex items-center justify-between">
                                    <span
                                        class="font-medium text-slate-600 dark:text-slate-200"
                                        >Paragraphs</span
                                    >
                                    <span
                                        class="text-sm font-semibold text-slate-900 dark:text-slate-100"
                                        x-text="paragraphCountLabel()"
                                    ></span>
                                </li>
                                <li class="flex items-center justify-between">
                                    <span
                                        class="font-medium text-slate-600 dark:text-slate-200"
                                        >Modification Date</span
                                    >
                                    <span
                                        class="text-sm font-medium text-slate-900 dark:text-slate-100"
                                        x-text="statisticsUpdatedLabel()"
                                    ></span>
                                </li>
                                <li class="flex items-center justify-between">
                                    <span
                                        class="font-medium text-slate-600 dark:text-slate-200"
                                        >Create Date</span
                                    >
                                    <span
                                        class="text-sm font-medium text-slate-900 dark:text-slate-100"
                                        x-text="statisticsCreatedLabel()"
                                    ></span>
                                </li>
                            </ul>
                        </div>
                    </div>
                    <button
                        type="button"
                        class="inline-flex items-center justify-center gap-2 rounded-xl border border-slate-200 px-4 py-2 font-medium text-slate-600 transition hover:border-blue-200 hover:text-blue-600 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/60 dark:hover:text-blue-200"
                        @click="openMetadataPanel()"
                    >
                        <svg
                            class="h-4 w-4"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="1.5"
                                d="M8.25 6.75h7.5M8.25 12h7.5M8.25 17.25h4.5"
                            ></path>
                        </svg>
                        <span>文章设置</span>
                    </button>
                </div>
                <div
                    class="mt-3 flex items-center justify-between text-xs text-slate-500 dark:text-slate-400"
                >
                    <span class="font-medium">⌘/Ctrl + S</span>
                    <a
                        href="/admin/posts"
                        class="inline-flex items-center gap-2 rounded-lg border border-slate-200 px-3 py-1.5 font-medium text-slate-600 transition hover:border-slate-300 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:border-slate-600 dark:hover:text-slate-100"
                    >
                        <svg
                            class="h-4 w-4"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="1.5"
                                d="M10.5 6h7.125M10.5 12h7.125M10.5 18H17.625M6.375 6v12l-3-3H9.375"
                            ></path>
                        </svg>
                        <span>返回列表</span>
                    </a>
                </div>
            </div>
            <button
                type="button"
                class="flex h-12 w-12 items-center justify-center rounded-full border border-slate-200/70 bg-white/75 text-slate-500 shadow-md shadow-slate-200/50 transition hover:bg-white focus:outline-none focus:ring-2 focus:ring-blue-100 dark:border-slate-600/70 dark:bg-slate-800/80 dark:text-slate-200 dark:hover:bg-slate-700/80"
                @click="toggleQuickActions()"
                :aria-expanded="quickActionsExpanded"
                aria-label="快速操作"
            >
                <svg
                    x-show="!quickActionsExpanded"
                    class="h-5 w-5"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="1.5"
                        d="M12 6v12M6 12h12"
                    ></path>
                </svg>
                <svg
                    x-show="quickActionsExpanded"
                    class="h-5 w-5"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="1.5"
                        d="M6 12h12"
                    ></path>
                </svg>
            </button>
        </div>
    </div>

    <div
        x-show="panelOpen"
        x-transition.opacity
        class="fixed inset-0 z-40 flex"
        @keydown.escape.window="closePanel()"
    >
        <div
            class="hidden flex-1 bg-slate-900/40 backdrop-blur-sm md:block"
            @click="closePanel()"
        ></div>
        <div
            class="ml-auto flex h-full w-full max-w-md flex-col bg-white shadow-2xl transition dark:bg-slate-900"
            x-transition:enter="transform ease-out duration-200"
            x-transition:enter-start="translate-x-full"
            x-transition:enter-end="translate-x-0"
            x-transition:leave="transform ease-in duration-200"
            x-transition:leave-start="translate-x-0"
            x-transition:leave-end="translate-x-full"
        >
            <header
                class="flex items-start justify-between border-b border-slate-200 px-6 pb-4 pt-6 dark:border-slate-800"
            >
                <div class="space-y-1">
                    <h2
                        class="text-lg font-semibold text-slate-900 dark:text-slate-100"
                    >
                        文章设置
                    </h2>
                    <p class="text-xs text-slate-500 dark:text-slate-400">
                        管理文章摘要、封面与标签等元数据。
                    </p>
                </div>
                <button
                    type="button"
                    class="rounded-full p-2 text-slate-400 transition-colors hover:text-slate-600 focus:outline-none focus:ring-2 focus:ring-slate-200 dark:text-slate-500 dark:hover:text-slate-200 dark:focus:ring-slate-700/60"
                    @click="closePanel()"
                >
                    <svg
                        class="h-4 w-4"
                        viewBox="0 0 20 20"
                        fill="none"
                        stroke="currentColor"
                    >
                        <path
                            stroke-linecap="round"
                            stroke-width="1.6"
                            d="M5.5 5.5l9 9m0-9l-9 9"
                        ></path>
                    </svg>
                </button>
            </header>
            <div class="flex-1 space-y-6 overflow-y-auto px-6 pb-10 pt-6">
                <section class="space-y-3">
                    <div
                        class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between"
                    >
                        <div>
                            <h3
                                class="text-sm font-semibold text-slate-900 dark:text-slate-100"
                            >
                                文章摘要
                            </h3>
                            <p
                                class="text-xs text-slate-500 dark:text-slate-400"
                            >
                                用于列表页描述和 SEO 元信息。
                            </p>
                        </div>
                        <button
                            type="button"
                            class="inline-flex items-center gap-2 rounded-lg border border-slate-200 px-3 py-1.5 text-xs font-medium text-slate-600 transition-colors hover:border-blue-200 hover:text-blue-600 disabled:cursor-not-allowed disabled:border-slate-200 disabled:text-slate-300 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/50 dark:hover:text-blue-200 dark:disabled:border-slate-700 dark:disabled:text-slate-600"
                            @click="generateSummary()"
                            :disabled="generatingSummary"
                        >
                            <svg
                                class="h-4 w-4"
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                            >
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="1.5"
                                    d="M12 3v3m0 12v3m9-9h-3M6 12H3m15.364-6.364l-2.121 2.121M8.757 15.243l-2.121 2.121m0-11.314l2.121 2.121m8.486 8.486l2.121 2.121"
                                ></path>
                            </svg>
                            <span x-show="!generatingSummary"
                                >生成 AI 摘要</span
                            >
                            <span x-show="generatingSummary">生成中...</span>
                        </button>
                    </div>
                    <textarea
                        rows="6"
                        x-model="metadata.summary"
                        @input.debounce.500ms="handleSummaryChange(metadata.summary)"
                        placeholder="简要概括文章核心观点"
                        class="w-full rounded-xl border border-slate-300 px-3 py-2 text-sm text-slate-900 placeholder-slate-400 transition-colors focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-100 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-100 dark:placeholder-slate-500 dark:focus:border-blue-500/60 dark:focus:ring-blue-500/30"
                    ></textarea>
                    <template x-if="summaryUsage">
                        <p class="text-xs text-slate-400 dark:text-slate-500">
                            提示词用量：<span
                                x-text="summaryUsageLabel()"
                            ></span>
                        </p>
                    </template>
                </section>

                <section class="space-y-4">
                    <div
                        class="flex flex-col gap-2 sm:flex-row sm:items-start sm:justify-between"
                    >
                        <div>
                            <h3
                                class="text-sm font-semibold text-slate-900 dark:text-slate-100"
                            >
                                文章标签
                            </h3>
                            <p
                                class="text-xs text-slate-500 dark:text-slate-400"
                            >
                                为文章挑选合适标签，帮助归档与专题聚合。
                            </p>
                        </div>
                        <a
                            href="/admin/tags"
                            class="inline-flex items-center gap-1 text-xs font-medium text-blue-600 transition hover:text-blue-500 dark:text-blue-300 dark:hover:text-blue-200"
                        >
                            <svg
                                class="h-3.5 w-3.5"
                                viewBox="0 0 20 20"
                                fill="none"
                                stroke="currentColor"
                            >
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="1.4"
                                    d="M10 4.167v11.666M4.167 10h11.666"
                                ></path>
                            </svg>
                            <span>管理标签</span>
                        </a>
                    </div>
                    <template x-if="tagError">
                        <div
                            class="rounded-xl border border-rose-200 bg-rose-50/80 px-4 py-3 text-xs text-rose-600 dark:border-rose-500/40 dark:bg-rose-500/10 dark:text-rose-200"
                            x-text="tagError"
                        ></div>
                    </template>
                    <div
                        class="rounded-xl border border-slate-200/80 bg-white/70 px-3 py-3 dark:border-slate-700 dark:bg-slate-900/40"
                        x-show="availableTags.length > 0"
                        x-cloak
                    >
                        <div class="max-h-60 space-y-2 overflow-y-auto pr-1">
                            <template
                                x-for="tag in availableTags"
                                :key="`panel-tag-${tag.id}`"
                            >
                                <label
                                    class="flex items-center gap-3 rounded-lg px-2 py-1.5 text-sm text-slate-600 transition hover:bg-slate-50 dark:text-slate-300 dark:hover:bg-slate-800/60"
                                >
                                    <input
                                        type="checkbox"
                                        class="h-4 w-4 rounded border-slate-300 text-blue-600 focus:ring-blue-500 dark:border-slate-600 dark:bg-slate-800"
                                        :value="tag.id"
                                        :checked="isTagSelected(tag.id)"
                                        @change="toggleTag(tag)"
                                    />
                                    <span
                                        class="truncate"
                                        x-text="tag.name"
                                    ></span>
                                </label>
                            </template>
                        </div>
                    </div>
                    <div
                        x-show="!tagError && availableTags.length === 0"
                        x-cloak
                        class="rounded-xl border border-dashed border-slate-200 px-4 py-3 text-xs text-slate-500 dark:border-slate-700 dark:text-slate-400"
                    >
                        暂无可用标签，请先前往标签管理创建。
                    </div>
                    <div
                        class="flex flex-wrap items-center gap-2 text-[11px] text-slate-400 dark:text-slate-500"
                    >
                        <span class="font-semibold uppercase tracking-wide"
                            >已选择</span
                        >
                        <template x-if="metadata.tags.length === 0">
                            <span
                                class="rounded-full bg-slate-100 px-2 py-0.5 font-medium text-slate-500 dark:bg-slate-800/70 dark:text-slate-300"
                                >未选择</span
                            >
                        </template>
                        <template
                            x-for="tag in metadata.tags"
                            :key="`panel-selected-${tag.id}`"
                        >
                            <span
                                class="rounded-full bg-blue-50 px-2 py-0.5 text-xs font-medium text-blue-600 dark:bg-blue-500/20 dark:text-blue-200"
                                x-text="tag.name"
                            ></span>
                        </template>
                    </div>
                </section>

                <section class="space-y-3">
                    <div
                        class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between"
                    >
                        <div>
                            <h3
                                class="text-sm font-semibold text-slate-900 dark:text-slate-100"
                            >
                                发布时间
                            </h3>
                            <p
                                class="text-xs text-slate-500 dark:text-slate-400"
                            >
                                留空则发布时使用当前时间，已发布文章会默认沿用最近的发布时间。
                            </p>
                        </div>
                        <div
                            class="flex flex-wrap items-center gap-2 text-xs text-slate-500 dark:text-slate-400"
                        >
                            <button
                                type="button"
                                class="inline-flex items-center gap-1 rounded-lg border border-slate-200 px-3 py-1.5 font-medium text-slate-600 transition hover:border-blue-200 hover:text-blue-600 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/50 dark:hover:text-blue-200"
                                @click="setPublishTimeToNow()"
                            >
                                <svg
                                    class="h-3.5 w-3.5"
                                    viewBox="0 0 20 20"
                                    fill="none"
                                    stroke="currentColor"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="1.4"
                                        d="M10 4.167v6.111l4.444 2.223M10 18.333A8.333 8.333 0 1 0 10 1.667a8.333 8.333 0 0 0 0 16.666Z"
                                    ></path>
                                </svg>
                                <span>设为当前时间</span>
                            </button>
                            <button
                                type="button"
                                class="inline-flex items-center gap-1 rounded-lg border border-slate-200 px-3 py-1.5 font-medium text-slate-600 transition hover:border-blue-200 hover:text-blue-600 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/50 dark:hover:text-blue-200"
                                @click="clearPublishTime()"
                            >
                                <svg
                                    class="h-3.5 w-3.5"
                                    viewBox="0 0 20 20"
                                    fill="none"
                                    stroke="currentColor"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="1.4"
                                        d="M5.5 5.5l9 9m0-9l-9 9"
                                    ></path>
                                </svg>
                                <span>清空</span>
                            </button>
                        </div>
                    </div>
                    <div class="space-y-2">
                        <input
                            type="datetime-local"
                            x-model="publishAtInput"
                            @input="handlePublishAtInput($event.target.value)"
                            class="w-full rounded-xl border border-slate-300 px-3 py-2 text-sm text-slate-900 transition-colors focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-100 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-100 dark:focus:border-blue-500/60 dark:focus:ring-blue-500/30"
                        />
                        <template x-if="publishAtError">
                            <p
                                class="text-xs text-rose-600 dark:text-rose-300"
                                x-text="publishAtError"
                            ></p>
                        </template>
                        <p
                            class="text-xs text-slate-500 dark:text-slate-400"
                            x-text="publishTimeHelpText()"
                        ></p>
                    </div>
                </section>

                <section class="space-y-3">
                    <div
                        class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between"
                    >
                        <div>
                            <h3
                                class="text-sm font-semibold text-slate-900 dark:text-slate-100"
                            >
                                文章封面<span
                                    class="ml-2 rounded-full bg-slate-100 px-2 py-0.5 text-[11px] font-medium text-slate-500 dark:bg-slate-800/70 dark:text-slate-400"
                                    >发布前必填</span
                                >
                            </h3>
                            <p
                                class="text-xs text-slate-500 dark:text-slate-400"
                            >
                                建议尺寸 ≥ 1200px，可裁剪为 16:9 或 3:4。
                            </p>
                        </div>
                        <div class="flex flex-wrap items-center gap-2">
                            <input
                                type="file"
                                accept="image/*"
                                class="hidden"
                                x-ref="coverInput"
                                @change="handleCoverFile($event)"
                            />
                            <button
                                type="button"
                                class="inline-flex items-center gap-2 rounded-lg border border-slate-300 px-3 py-1.5 text-xs font-medium text-slate-600 transition-colors hover:border-blue-300 hover:bg-blue-50 hover:text-blue-600 dark:border-slate-700 dark:text-slate-300 dark:hover:border-blue-400/60 dark:hover:bg-blue-500/10 dark:hover:text-blue-200"
                                @click="openCoverPicker()"
                            >
                                选择图片
                            </button>
                            <button
                                type="button"
                                class="inline-flex items-center gap-2 rounded-lg border border-slate-200 px-3 py-1.5 text-xs font-medium text-slate-600 transition-colors hover:border-slate-300 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:border-slate-600 dark:hover:text-slate-100"
                                @click="reCropCover()"
                                x-show="metadata.cover.url"
                                x-cloak
                            >
                                重新裁剪
                            </button>
                        </div>
                    </div>
                    <div
                        x-show="metadata.cover.url"
                        x-cloak
                        class="space-y-4 rounded-xl border border-slate-200 bg-slate-50/70 p-4 transition-colors dark:border-slate-700 dark:bg-slate-900/60"
                    >
                        <div
                            class="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between"
                        >
                            <div class="flex items-center gap-4">
                                <img
                                    :src="metadata.cover.url"
                                    alt="封面预览"
                                    class="h-28 w-28 rounded-lg object-cover shadow-sm"
                                />
                                <div
                                    class="space-y-1 text-xs text-slate-600 dark:text-slate-300"
                                >
                                    <p
                                        class="font-medium text-slate-800 dark:text-slate-100"
                                    >
                                        当前封面
                                    </p>
                                    <p
                                        class="text-slate-500 dark:text-slate-400"
                                    >
                                        尺寸：<span
                                            x-text="formatCoverSize()"
                                        ></span>
                                    </p>
                                    <p
                                        class="text-[11px] text-slate-400 dark:text-slate-500"
                                    >
                                        保存后将自动适配首页与分享卡片。
                                    </p>
                                </div>
                            </div>
                            <div class="flex items-center gap-2 text-xs">
                                <button
                                    type="button"
                                    class="rounded-lg border border-slate-200 px-3 py-1.5 font-medium text-slate-600 transition-colors hover:bg-slate-100 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800 dark:hover:text-slate-100"
                                    @click="reCropCover()"
                                >
                                    重新裁剪
                                </button>
                                <button
                                    type="button"
                                    class="rounded-lg border border-rose-200 px-3 py-1.5 font-medium text-rose-600 transition-colors hover:bg-rose-50 dark:border-rose-500/50 dark:text-rose-300 dark:hover:bg-rose-500/10"
                                    @click="removeCover()"
                                >
                                    移除
                                </button>
                            </div>
                        </div>
                    </div>
                    <div
                        x-show="!metadata.cover.url"
                        class="rounded-xl border border-dashed border-slate-200 bg-white/70 p-6 text-xs text-slate-500 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-400"
                    >
                        还没有封面，上传后可用于首页展示与社交分享卡片。
                    </div>
                </section>

                <section
                    class="rounded-xl border border-slate-200 bg-slate-50/60 p-4 text-xs text-slate-500 transition-colors dark:border-slate-800 dark:bg-slate-900/60 dark:text-slate-400"
                >
                    <div
                        class="flex items-center gap-2 text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500"
                    >
                        <span>草稿状态</span>
                        <span
                            class="h-1.5 w-1.5 rounded-full"
                            :class="autoSaveIndicatorClasses()"
                        ></span>
                    </div>
                    <p
                        class="mt-2 leading-relaxed"
                        x-text="autoSaveDescription()"
                    ></p>
                </section>
            </div>
        </div>
    </div>

    <div
        x-show="optimizationModal"
        x-cloak
        class="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 px-4"
    >
        <div
            class="relative w-full max-w-5xl rounded-2xl border border-slate-200 bg-white p-6 shadow-2xl transition-colors dark:border-slate-800 dark:bg-slate-950"
        >
            <div class="flex items-start justify-between gap-4">
                <div>
                    <h3
                        class="text-lg font-semibold text-slate-900 dark:text-slate-100"
                    >
                        AI 全文优化预览
                    </h3>
                    <p class="mt-1 text-sm text-slate-500 dark:text-slate-400">
                        左右对照新旧版本，确认后可一键替换。
                    </p>
                </div>
                <button
                    type="button"
                    class="rounded-full p-1.5 text-slate-400 transition hover:text-slate-600 dark:text-slate-500 dark:hover:text-slate-300"
                    @click="closeOptimizationModal()"
                    aria-label="关闭优化预览"
                >
                    ✕
                </button>
            </div>
            <template x-if="optimizationUsage">
                <div
                    class="mt-4 flex flex-wrap items-center gap-2 text-xs text-slate-500 dark:text-slate-400"
                >
                    <span
                        class="inline-flex items-center gap-1 rounded-full bg-slate-100 px-3 py-1 dark:bg-slate-800/70"
                    >
                        <span class="text-slate-500 dark:text-slate-400"
                            >提示词 Token：</span
                        >
                        <span
                            x-text="optimizationUsage.prompt_tokens ?? optimizationUsage.promptTokens"
                        ></span>
                    </span>
                    <span
                        class="inline-flex items-center gap-1 rounded-full bg-slate-100 px-3 py-1 dark:bg-slate-800/70"
                    >
                        <span class="text-slate-500 dark:text-slate-400"
                            >生成 Token：</span
                        >
                        <span
                            x-text="optimizationUsage.completion_tokens ?? optimizationUsage.completionTokens"
                        ></span>
                    </span>
                </div>
            </template>
            <div class="relative mt-4">
                <div
                    x-show="optimizingContent"
                    x-cloak
                    class="absolute inset-0 z-10 flex items-center justify-center rounded-xl border border-dashed border-slate-300 bg-white/85 backdrop-blur-sm dark:border-slate-700 dark:bg-slate-950/80"
                >
                    <div
                        class="flex items-center gap-2 text-sm text-slate-600 dark:text-slate-300"
                    >
                        <span class="animate-pulse">正在优化全文...</span>
                    </div>
                </div>
                <div class="grid gap-4 lg:grid-cols-2">
                    <div
                        class="rounded-xl border border-slate-200 bg-white p-4 dark:border-slate-700 dark:bg-slate-900/70"
                    >
                        <div
                            class="flex items-center justify-between text-xs font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500"
                        >
                            <span>当前正文</span>
                        </div>
                        <div
                            class="mt-3 max-h-[60vh] overflow-y-auto rounded-lg border border-slate-100/80 bg-slate-50/60 px-4 py-3 text-sm leading-6 text-slate-700 dark:border-slate-700/60 dark:bg-slate-900/40 dark:text-slate-200"
                        >
                            <div
                                x-show="!optimizationPreviews.source.ready"
                                class="text-xs text-slate-400 dark:text-slate-500"
                            >
                                暂无内容
                            </div>
                            <div
                                x-ref="optimizationSourcePreview"
                                x-show="optimizationPreviews.source.ready"
                                class="milkdown-preview"
                            ></div>
                        </div>
                    </div>
                    <div
                        class="rounded-xl border border-emerald-200 bg-emerald-50/70 p-4 text-sm leading-6 text-slate-700 dark:border-emerald-500/40 dark:bg-emerald-500/10 dark:text-emerald-100"
                    >
                        <div
                            class="flex items-center justify-between text-xs font-semibold uppercase tracking-wide"
                        >
                            <span>优化提案</span>
                        </div>
                        <div
                            class="mt-3 max-h-[60vh] overflow-y-auto rounded-lg border border-emerald-200/60 bg-white/70 px-4 py-3 text-sm leading-6 text-slate-700 dark:border-emerald-500/30 dark:bg-slate-900/60 dark:text-emerald-50"
                        >
                            <div
                                x-show="!optimizationPreviews.optimized.ready"
                                class="text-xs text-emerald-500/70 dark:text-emerald-200/70"
                            >
                                等待优化结果...
                            </div>
                            <div
                                x-ref="optimizedContentPreview"
                                x-show="optimizationPreviews.optimized.ready"
                                class="milkdown-preview"
                            ></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="mt-6 flex justify-end gap-3 text-sm">
                <button
                    type="button"
                    class="rounded-lg border border-slate-200 px-4 py-2 text-slate-600 transition hover:bg-slate-100 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800 dark:hover:text-slate-100"
                    @click="closeOptimizationModal()"
                >
                    关闭
                </button>
                <button
                    type="button"
                    class="rounded-lg border border-emerald-200 px-4 py-2 font-medium text-emerald-600 transition hover:bg-emerald-50 disabled:cursor-not-allowed disabled:text-slate-400 dark:border-emerald-500/40 dark:text-emerald-300 dark:hover:bg-emerald-500/10"
                    @click="optimizeContent()"
                    :disabled="optimizingContent"
                >
                    重新生成
                </button>
                <button
                    type="button"
                    class="rounded-lg bg-emerald-600 px-4 py-2 font-medium text-white transition hover:bg-emerald-500 dark:hover:bg-emerald-500/90"
                    @click="applyOptimization()"
                >
                    替换正文
                </button>
            </div>
        </div>
    </div>

    <div
        x-show="inlineAI.open"
        x-cloak
        class="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/50 px-4 backdrop-blur-sm"
        @keydown.escape.window="closeInlineAI()"
    >
        <div
            class="relative w-full max-w-3xl overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-2xl transition-colors dark:border-slate-800 dark:bg-slate-950"
            x-trap.noscroll="inlineAI.open"
        >
            <div
                class="flex items-start justify-between gap-4 border-b border-slate-200 px-6 py-4 dark:border-slate-800"
            >
                <div>
                    <h3
                        class="text-lg font-semibold text-slate-900 dark:text-slate-100"
                    >
                        AI Chat 改写
                    </h3>
                    <p class="mt-1 text-xs text-slate-500 dark:text-slate-400">
                        选中段落后输入你的需求，模型将返回改写建议。
                    </p>
                </div>
                <button
                    type="button"
                    class="rounded-full p-1.5 text-slate-400 transition hover:text-slate-600 dark:text-slate-500 dark:hover:text-slate-300"
                    @click="closeInlineAI()"
                    aria-label="关闭 AI Chat 弹窗"
                >
                    ✕
                </button>
            </div>
            <div
                class="flex max-h-[70vh] flex-col gap-5 overflow-y-auto px-6 py-6"
            >
                <div class="space-y-2">
                    <p
                        class="text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500"
                    >
                        原始选区
                    </p>
                    <div
                        class="rounded-xl border border-slate-200 bg-slate-50/80 p-3 text-xs leading-relaxed text-slate-700 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-300 whitespace-pre-wrap break-words"
                        x-text="inlineAI.selection.text || inlineAI.selection.normalized"
                    ></div>
                    <template
                        x-if="inlineAI.selection.context && inlineAI.selection.context.trim() && inlineAI.selection.context.trim() !== (inlineAI.selection.text || inlineAI.selection.normalized || '').trim()"
                    >
                        <div class="space-y-2">
                            <p
                                class="text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500"
                            >
                                上下文参考
                            </p>
                            <div
                                class="rounded-xl border border-dashed border-slate-200 bg-white p-3 text-xs leading-relaxed text-slate-600 dark:border-slate-700 dark:bg-slate-900/50 dark:text-slate-300 whitespace-pre-wrap break-words"
                                x-text="inlineAI.selection.context"
                            ></div>
                        </div>
                    </template>
                </div>
                <div class="space-y-2">
                    <label
                        class="text-sm font-medium text-slate-700 dark:text-slate-200"
                        >改写指令</label
                    >
                    <textarea
                        rows="3"
                        x-model="inlineAI.instruction"
                        placeholder="例如：请改写成更具鼓动性的语气，并保留原有数据引用。"
                        class="w-full resize-y rounded-xl border border-slate-300 px-3 py-2 text-sm text-slate-900 placeholder-slate-400 transition focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-100 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-100 dark:placeholder-slate-500 dark:focus:border-blue-400 dark:focus:ring-blue-500/40"
                    ></textarea>
                </div>
                <template x-if="inlineAI.error">
                    <div
                        class="rounded-xl border border-rose-200 bg-rose-50/80 px-3 py-2 text-xs text-rose-600 dark:border-rose-500/50 dark:bg-rose-500/10 dark:text-rose-200"
                        x-text="inlineAI.error"
                    ></div>
                </template>
                <div class="flex flex-wrap items-center gap-3">
                    <button
                        type="button"
                        class="inline-flex items-center gap-2 rounded-xl bg-blue-600 px-4 py-2 text-sm font-medium text-white transition hover:bg-blue-500 disabled:cursor-not-allowed disabled:bg-slate-300 dark:bg-blue-500 dark:hover:bg-blue-400 dark:disabled:bg-slate-700/70"
                        @click="runInlineAIChat()"
                        :disabled="inlineAI.loading"
                    >
                        <svg
                            x-show="inlineAI.loading"
                            class="h-4 w-4 animate-spin"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="1.5"
                                d="M12 3v3m4.95 1.05-2.12 2.12M21 12h-3m-1.05 4.95-2.12-2.12M12 21v-3m-4.95-1.05 2.12-2.12M3 12h3m1.05-4.95 2.12 2.12"
                            ></path>
                        </svg>
                        <svg
                            x-show="!inlineAI.loading"
                            class="h-4 w-4"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="1.5"
                                d="M12 3l2.5 6.5L21 11l-5 4.5 1.5 6.5L12 18l-5.5 4 1.5-6.5L3 11l6.5-1.5L12 3z"
                            ></path>
                        </svg>
                        <span
                            x-text="inlineAI.loading ? '生成中…' : '生成改写建议'"
                        ></span>
                    </button>
                    <template x-if="inlineAI.usage">
                        <span
                            class="rounded-full bg-slate-100 px-3 py-1 text-[11px] font-semibold text-slate-500 dark:bg-slate-800/70 dark:text-slate-300"
                            x-text="inlineAIUsageLabel()"
                        ></span>
                    </template>
                </div>
                <template x-if="inlineAI.suggestion">
                    <div class="space-y-2">
                        <p
                            class="text-[11px] font-semibold uppercase tracking-wide text-slate-400 dark:text-slate-500"
                        >
                            AI 改写建议
                        </p>
                        <div
                            class="rounded-xl border border-blue-200 bg-blue-50/70 p-3 text-sm leading-relaxed text-slate-800 dark:border-blue-500/40 dark:bg-blue-500/10 dark:text-slate-200 whitespace-pre-wrap break-words"
                            x-text="inlineAI.suggestion"
                        ></div>
                    </div>
                </template>
            </div>
            <div
                class="flex flex-wrap items-center justify-between gap-3 border-t border-slate-200 bg-slate-50 px-6 py-4 dark:border-slate-800 dark:bg-slate-900/60"
            >
                <div class="flex items-center gap-2">
                    <button
                        type="button"
                        class="inline-flex items-center gap-2 rounded-xl border border-slate-300 px-4 py-2 text-sm font-medium text-slate-600 transition hover:border-slate-400 hover:text-slate-900 disabled:cursor-not-allowed disabled:opacity-60 dark:border-slate-700 dark:text-slate-300 dark:hover:border-slate-500 dark:hover:text-slate-100"
                        @click="copyInlineAISuggestion()"
                        :disabled="!inlineAI.suggestion"
                    >
                        <svg
                            class="h-4 w-4"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="1.5"
                                d="M9 9V5.25A2.25 2.25 0 0 1 11.25 3h7.5A2.25 2.25 0 0 1 21 5.25v7.5A2.25 2.25 0 0 1 18.75 15H15m-6 6H5.25A2.25 2.25 0 0 1 3 18.75v-7.5A2.25 2.25 0 0 1 5.25 9h7.5A2.25 2.25 0 0 1 15 11.25v7.5A2.25 2.25 0 0 1 12.75 21H9Z"
                            ></path>
                        </svg>
                        <span>复制建议</span>
                    </button>
                </div>
                <div class="flex items-center gap-3">
                    <button
                        type="button"
                        class="rounded-xl border border-slate-300 px-4 py-2 text-sm font-medium text-slate-600 transition hover:border-slate-400 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:border-slate-500 dark:hover:text-slate-100"
                        @click="closeInlineAI()"
                    >
                        取消
                    </button>
                    <button
                        type="button"
                        class="inline-flex items-center gap-2 rounded-xl bg-slate-900 px-4 py-2 text-sm font-semibold text-white transition hover:bg-slate-800 disabled:cursor-not-allowed disabled:bg-slate-400 dark:bg-blue-500 dark:hover:bg-blue-400 dark:disabled:bg-slate-700"
                        @click="applyInlineAISuggestion()"
                        :disabled="!inlineAI.suggestion"
                    >
                        应用到选区
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div
        x-show="coverModal"
        x-cloak
        class="fixed inset-0 z-50 flex items-center justify-center bg-slate-900/60 px-4"
    >
        <div
            class="relative w-full max-w-3xl rounded-2xl bg-white p-6 shadow-2xl transition-colors dark:bg-slate-950"
        >
            <h3
                class="text-lg font-semibold text-slate-900 dark:text-slate-100"
            >
                裁剪封面
            </h3>
            <div class="mt-4 flex flex-col gap-4">
                <div
                    class="flex flex-wrap items-center gap-2 text-xs text-slate-500 dark:text-slate-400"
                >
                    <span class="font-medium text-slate-600 dark:text-slate-300"
                        >裁剪比例：</span
                    >
                    <button
                        type="button"
                        class="rounded-lg border px-3 py-1.5 transition-colors"
                        :class="cropAspect === '16:9' ? 'border-blue-500 bg-blue-50 text-blue-600 dark:border-blue-400/70 dark:bg-blue-500/10 dark:text-blue-200' : 'border-slate-200 text-slate-600 hover:bg-slate-100 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800'"
                        @click="setAspect('16:9')"
                    >
                        16 : 9
                    </button>
                    <button
                        type="button"
                        class="rounded-lg border px-3 py-1.5 transition-colors"
                        :class="cropAspect === '3:4' ? 'border-blue-500 bg-blue-50 text-blue-600 dark:border-blue-400/70 dark:bg-blue-500/10 dark:text-blue-200' : 'border-slate-200 text-slate-600 hover:bg-slate-100 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800'"
                        @click="setAspect('3:4')"
                    >
                        3 : 4
                    </button>
                </div>
                <div
                    class="max-h-[60vh] overflow-hidden rounded-xl border border-slate-200 dark:border-slate-700"
                >
                    <img
                        x-ref="cropperImage"
                        :src="coverSource"
                        alt="裁剪预览"
                        class="max-h-[60vh] w-full object-contain"
                    />
                </div>
            </div>
            <div class="mt-6 flex justify-end gap-3 text-sm">
                <button
                    type="button"
                    class="rounded-lg border border-slate-200 px-4 py-2 text-slate-600 transition-colors hover:bg-slate-100 hover:text-slate-900 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800 dark:hover:text-slate-100"
                    @click="closeCropper()"
                    :disabled="uploadingCover"
                >
                    取消
                </button>
                <button
                    type="button"
                    class="rounded-lg bg-blue-600 px-4 py-2 text-white transition-colors hover:bg-blue-500 disabled:cursor-not-allowed disabled:bg-slate-300 dark:hover:bg-blue-500/90 dark:disabled:bg-slate-700/70"
                    @click="confirmCrop()"
                    :disabled="uploadingCover"
                >
                    <span x-show="!uploadingCover">确认裁剪</span>
                    <span x-show="uploadingCover">上传中...</span>
                </button>
            </div>
        </div>
    </div>
</div>

<script>
    window.__MILKDOWN_V2__ = {{$initial | toJSON}};
    document.body.classList.add('milkdown-immersive');
    const milkdownCleanup = () => {
            document.body.classList.remove('milkdown-immersive');
            const controller = window.MilkdownV2?.controller;
            if (controller && typeof controller.dispose === 'function') {
                    try {
                            controller.dispose();
                    } catch (error) {
                            console.error('[milkdown] 清理控制器失败', error);
                    }
            }
            const crepe = window.MilkdownV2?.crepe;
            if (crepe && typeof crepe.destroy === 'function') {
                    void crepe.destroy();
            }
    };
    window.addEventListener('pagehide', milkdownCleanup, { once: true });
    window.addEventListener('beforeunload', milkdownCleanup, { once: true });
</script>
<script>
    function setupPostEditorToc() {
        const factory = window.CommitLog?.toc?.createEditorController;
        if (typeof factory !== "function") {
            return null;
        }
        return factory();
    }

    document.addEventListener("alpine:init", () => {
        const sanitizeString = (value) =>
            typeof value === "string" ? value : "";
        const sanitizeNumber = (value) => {
            const parsed = Number(value);
            return Number.isFinite(parsed) ? parsed : 0;
        };
        const toDate = (value) => {
            if (!value) {
                return null;
            }
            if (value instanceof Date && !Number.isNaN(value.getTime())) {
                return value;
            }
            const timestamp = Date.parse(value);
            if (Number.isNaN(timestamp)) {
                return null;
            }
            return new Date(timestamp);
        };
        const escapeHtml = (text) =>
            text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");

        const fallbackMarkdownToHtml = (value) => {
            const blocks = value
                .split(/\n{2,}/)
                .map(
                    (block) =>
                        `<p class="whitespace-pre-wrap break-words">${escapeHtml(block).replace(/\n/g, "<br>")}</p>`,
                )
                .join("");
            return `<div class="space-y-4">${blocks}</div>`;
        };

        const toast =
            window.AdminUI?.toast ||
            ((payload) => {
                const message =
                    typeof payload === "string" ? payload : payload?.message;
                if (message) {
                    console.log("[toast]", message);
                }
            });

        Alpine.data("postEditorShell", () => ({
            controller: null,
            contentMetrics: { words: 0, characters: 0, paragraphs: 0 },
            numberFormatter: null,
            handleMetricsUpdate: null,
            handlePublicationUpdate: null,
            panelOpen: false,
            quickActionsExpanded: false,
            quickActionsHovering: false,
            quickActionsTimer: null,
            statisticsMenuOpen: false,
            availableTags: [],
            selectedTagIDs: [],
            tagError: "",
            postCreatedAt: "",
            postUpdatedAt: "",
            metadata: {
                summary: "",
                cover: { url: "", width: 0, height: 0 },
                tags: [],
            },
            summaryUsage: null,
            optimizationUsage: null,
            generatingSummary: false,
            optimizingContent: false,
            resettingFromPublication: false,
            savingDraft: false,
            autoSaving: false,
            autoSavePending: false,
            autoSaveError: "",
            lastAutoSavedAt: null,
            postId: "new",
            coverModal: false,
            coverSource: "",
            cropper: null,
            cropAspect: "16:9",
            uploadingCover: false,
            optimizationModal: false,
            optimizationSource: "",
            optimizedContent: "",
            optimizationPreviews: {
                source: {
                    instance: null,
                    mount: null,
                    ready: false,
                    rendering: null,
                },
                optimized: {
                    instance: null,
                    mount: null,
                    ready: false,
                    rendering: null,
                },
            },
            inlineAI: {
                open: false,
                instruction: "",
                selection: {
                    from: 0,
                    to: 0,
                    text: "",
                    normalized: "",
                    context: "",
                    revision: 0,
                },
                suggestion: "",
                usage: null,
                loading: false,
                error: "",
            },
            editorToc: null,
            editorTocRefreshTimer: null,
            statusTimer: null,
            handleInlineAIRequest: null,
            latestPublication: null,
            publishing: false,
            publishAtInput: "",
            publishAtManual: false,
            publishAtError: "",
            setupEditorToc() {
                if (this.editorToc) {
                    return;
                }
                if (typeof setupPostEditorToc !== "function") {
                    return;
                }
                const instance = setupPostEditorToc();
                if (instance) {
                    this.editorToc = instance;
                } else {
                    window.setTimeout(() => {
                        if (!this.editorToc) {
                            this.setupEditorToc();
                        }
                    }, 400);
                }
            },
            scheduleEditorTocRefresh() {
                if (!this.editorToc) {
                    this.setupEditorToc();
                }
                if (this.editorTocRefreshTimer) {
                    window.clearTimeout(this.editorTocRefreshTimer);
                }
                this.editorTocRefreshTimer = window.setTimeout(() => {
                    this.editorTocRefreshTimer = null;
                    if (
                        this.editorToc &&
                        typeof this.editorToc.refresh === "function"
                    ) {
                        this.editorToc.refresh();
                    } else if (!this.editorToc) {
                        this.setupEditorToc();
                    }
                }, 180);
            },
            destroyEditorToc() {
                if (this.editorTocRefreshTimer) {
                    window.clearTimeout(this.editorTocRefreshTimer);
                    this.editorTocRefreshTimer = null;
                }
                if (
                    this.editorToc &&
                    typeof this.editorToc.destroy === "function"
                ) {
                    this.editorToc.destroy();
                }
                this.editorToc = null;
            },
            init() {
                this.availableTags = this.normalizeTags(
                    window.__MILKDOWN_V2__?.allTags || [],
                );
                this.tagError = sanitizeString(
                    window.__MILKDOWN_V2__?.tagError || "",
                );
                if (window.__MILKDOWN_V2__?.post) {
                    this.syncTagsFromController(window.__MILKDOWN_V2__.post);
                }
                this.numberFormatter = new Intl.NumberFormat("zh-CN");
                this.latestPublication =
                    window.__MILKDOWN_V2__?.latestPublication || null;
                this.updatePublishAtFromSource(
                    this.latestPublication || window.__MILKDOWN_V2__?.post,
                );
                this.handleMetricsUpdate = (event) => {
                    const detail = event?.detail || {};
                    if (detail.metrics) {
                        this.applyContentMetrics(detail.metrics);
                    } else if (detail.controller?.contentMetrics) {
                        this.applyContentMetrics(
                            detail.controller.contentMetrics,
                        );
                    }
                    this.scheduleEditorTocRefresh();
                };
                this.handleInlineAIRequest = (event) => {
                    const selection = event?.detail?.selection || {};
                    const normalized = sanitizeString(
                        selection.normalizedText || selection.text || "",
                    );
                    if (!normalized.trim()) {
                        toast({
                            message: "请选择需要改写的段落后再试",
                            type: "warning",
                        });
                        return;
                    }
                    const from =
                        typeof selection.from === "number" &&
                        Number.isFinite(selection.from)
                            ? selection.from
                            : 0;
                    const to =
                        typeof selection.to === "number" &&
                        Number.isFinite(selection.to)
                            ? selection.to
                            : 0;
                    const context = sanitizeString(selection.context || "");
                    const revision =
                        typeof selection.revision === "number" &&
                        Number.isFinite(selection.revision)
                            ? selection.revision
                            : 0;
                    this.inlineAI.open = true;
                    this.inlineAI.instruction = "";
                    this.inlineAI.loading = false;
                    this.inlineAI.error = "";
                    this.inlineAI.suggestion = "";
                    this.inlineAI.usage = null;
                    this.inlineAI.selection = {
                        from,
                        to,
                        text: sanitizeString(selection.text || normalized),
                        normalized,
                        context,
                        revision,
                    };
                    if (window.MilkdownV2?.inlineAI?.hideToolbar) {
                        try {
                            window.MilkdownV2.inlineAI.hideToolbar();
                        } catch (error) {
                            console.warn(
                                "[post-editor] 隐藏 AI Chat 工具条失败",
                                error,
                            );
                        }
                    }
                };
                this.handlePublicationUpdate = (event) => {
                    const publication = event?.detail?.publication;
                    if (publication && typeof publication === "object") {
                        this.latestPublication = publication;
                        this.updatePublishAtFromSource(publication, {
                            force: true,
                        });
                    }
                };
                this.handleReady = (event) => {
                    if (event?.detail?.controller) {
                        this.attachController(event.detail.controller);
                    }
                    if (event?.detail?.post) {
                        this.syncPost(event.detail.post);
                    }
                    this.refreshStatus();
                    this.scheduleEditorTocRefresh();
                };
                this.handlePostUpdate = (event) => {
                    if (event?.detail?.controller) {
                        this.attachController(event.detail.controller);
                    }
                    if (event?.detail?.post) {
                        this.syncPost(event.detail.post);
                    }
                    this.refreshStatus();
                    this.scheduleEditorTocRefresh();
                };
                window.addEventListener(
                    "post-editor:inline-ai",
                    this.handleInlineAIRequest,
                );
                window.addEventListener(
                    "post-editor:publication",
                    this.handlePublicationUpdate,
                );
                window.addEventListener("post-editor:ready", this.handleReady);
                window.addEventListener(
                    "post-editor:post-updated",
                    this.handlePostUpdate,
                );
                window.addEventListener("post-editor:dirty", () =>
                    this.refreshStatus(),
                );
                window.addEventListener(
                    "post-editor:metrics",
                    this.handleMetricsUpdate,
                );
                this.tryAttachController();
                this.refreshStatus();
                this.statusTimer = window.setInterval(
                    () => this.refreshStatus(),
                    3000,
                );
                this.setupEditorToc();
                this.scheduleEditorTocRefresh();
                this.$nextTick(() => this.scheduleEditorTocRefresh());
                this.cleanup = () => {
                    this.destroyEditorToc();
                    if (this.statusTimer) {
                        window.clearInterval(this.statusTimer);
                        this.statusTimer = null;
                    }
                    this.cancelQuickActionsTimer();
                    window.removeEventListener(
                        "post-editor:ready",
                        this.handleReady,
                    );
                    window.removeEventListener(
                        "post-editor:post-updated",
                        this.handlePostUpdate,
                    );
                    if (this.handleMetricsUpdate) {
                        window.removeEventListener(
                            "post-editor:metrics",
                            this.handleMetricsUpdate,
                        );
                        this.handleMetricsUpdate = null;
                    }
                    if (this.handleInlineAIRequest) {
                        window.removeEventListener(
                            "post-editor:inline-ai",
                            this.handleInlineAIRequest,
                        );
                        this.handleInlineAIRequest = null;
                    }
                    if (this.handlePublicationUpdate) {
                        window.removeEventListener(
                            "post-editor:publication",
                            this.handlePublicationUpdate,
                        );
                        this.handlePublicationUpdate = null;
                    }
                    void this.destroyOptimizationPreview("source");
                    void this.destroyOptimizationPreview("optimized");
                };
                window.addEventListener("pagehide", this.cleanup, {
                    once: true,
                });
                window.addEventListener("beforeunload", this.cleanup, {
                    once: true,
                });
            },
            toggleQuickActions() {
                this.quickActionsExpanded = !this.quickActionsExpanded;
                if (this.quickActionsExpanded) {
                    this.closeStatisticsMenu();
                    this.cancelQuickActionsTimer();
                    this.scheduleQuickActionsCollapse();
                } else {
                    this.closeStatisticsMenu();
                    this.cancelQuickActionsTimer();
                }
            },
            collapseQuickActions() {
                if (!this.quickActionsExpanded) {
                    return;
                }
                this.quickActionsExpanded = false;
                this.closeStatisticsMenu();
                this.cancelQuickActionsTimer();
            },
            scheduleQuickActionsCollapse() {
                this.cancelQuickActionsTimer();
                this.quickActionsTimer = window.setTimeout(() => {
                    if (
                        !this.quickActionsHovering &&
                        !this.statisticsMenuOpen
                    ) {
                        this.collapseQuickActions();
                    }
                }, 2400);
            },
            cancelQuickActionsTimer() {
                if (this.quickActionsTimer) {
                    window.clearTimeout(this.quickActionsTimer);
                    this.quickActionsTimer = null;
                }
            },
            handleQuickActionsMouseEnter() {
                this.quickActionsHovering = true;
                this.cancelQuickActionsTimer();
            },
            handleQuickActionsMouseLeave() {
                this.quickActionsHovering = false;
                if (this.quickActionsExpanded) {
                    this.scheduleQuickActionsCollapse();
                }
            },
            handleQuickActionsFocusOut(event) {
                const next = event?.relatedTarget;
                if (!next || !event.currentTarget.contains(next)) {
                    this.handleQuickActionsMouseLeave();
                }
            },
            handleQuickActionsOutside() {
                this.collapseQuickActions();
            },
            toggleStatisticsMenu() {
                if (this.statisticsMenuOpen) {
                    this.closeStatisticsMenu();
                    return;
                }
                this.statisticsMenuOpen = true;
                this.cancelQuickActionsTimer();
            },
            closeStatisticsMenu() {
                if (!this.statisticsMenuOpen) {
                    return;
                }
                this.statisticsMenuOpen = false;
                if (this.quickActionsExpanded) {
                    this.scheduleQuickActionsCollapse();
                }
            },
            openMetadataPanel() {
                this.togglePanel(true);
                this.collapseQuickActions();
            },
            async publishArticle() {
                const controller = this.ensureController();
                if (!controller || typeof controller.publish !== "function") {
                    toast({
                        message: "编辑器尚未就绪，请稍后重试",
                        type: "error",
                    });
                    return;
                }
                if (this.publishing || this.savingDraft) {
                    return;
                }
                const publishOptions = this.buildPublishOptions();
                if (publishOptions === null) {
                    return;
                }
                this.publishing = true;
                try {
                    const success = await controller.publish(publishOptions);
                    if (success) {
                        if (
                            typeof controller.getLatestPublication ===
                            "function"
                        ) {
                            this.latestPublication =
                                controller.getLatestPublication() || null;
                        } else {
                            this.latestPublication =
                                controller.latestPublication || null;
                        }
                        this.updatePublishAtFromSource(this.latestPublication, {
                            force: true,
                        });
                        this.refreshStatus();
                    } else {
                        this.refreshStatus();
                    }
                } finally {
                    this.publishing = !!controller.publishing;
                }
            },
            resolveLatestPublicationObject() {
                if (
                    this.latestPublication &&
                    typeof this.latestPublication === "object"
                ) {
                    return this.latestPublication;
                }
                const controller = this.ensureController();
                if (!controller) {
                    return null;
                }
                if (typeof controller.getLatestPublication === "function") {
                    const resolved = controller.getLatestPublication();
                    if (resolved && typeof resolved === "object") {
                        return resolved;
                    }
                }
                if (
                    controller.latestPublication &&
                    typeof controller.latestPublication === "object"
                ) {
                    return controller.latestPublication;
                }
                return null;
            },
            async confirmResetToPublication() {
                this.closeStatisticsMenu();
                this.collapseQuickActions();
                const publication = this.resolveLatestPublicationObject();
                if (!publication) {
                    toast({
                        message: "当前没有线上版本可供重置",
                        type: "error",
                    });
                    return;
                }
                const message =
                    "将用当前线上发布的内容覆盖草稿，未保存的修改会丢失，确认继续？";
                if (
                    window.AdminUI &&
                    typeof window.AdminUI.confirm === "function"
                ) {
                    const confirmed = await window.AdminUI.confirm({
                        title: "重置为线上版本",
                        message,
                        description:
                            "系统会使用线上版本完全替换编辑器中的草稿内容，请先确认需要保留的修改已另存。",
                        confirmText: "重置",
                        cancelText: "取消",
                        tone: "danger",
                    });
                    if (!confirmed) {
                        return;
                    }
                } else if (!window.confirm(message)) {
                    return;
                }
                await this.resetDraftFromPublication();
            },
            async resetDraftFromPublication() {
                if (this.resettingFromPublication) {
                    return;
                }
                const controller = this.ensureController();
                if (
                    !controller ||
                    typeof controller.resetToLatestPublication !== "function"
                ) {
                    toast({
                        message: "编辑器尚未就绪，请稍后重试",
                        type: "error",
                    });
                    return;
                }
                const publication = this.resolveLatestPublicationObject();
                if (!publication) {
                    toast({
                        message: "当前没有线上版本可供重置",
                        type: "error",
                    });
                    return;
                }
                this.resettingFromPublication = true;
                try {
                    const restored = await controller.resetToLatestPublication({
                        publication,
                    });
                    if (restored) {
                        if (
                            typeof controller.getLatestPublication ===
                            "function"
                        ) {
                            this.latestPublication =
                                controller.getLatestPublication() ||
                                this.latestPublication;
                        } else if (controller.latestPublication) {
                            this.latestPublication =
                                controller.latestPublication;
                        }
                        this.syncPost(controller.postData);
                        this.scheduleEditorTocRefresh();
                        this.refreshStatus();
                        toast({
                            message: "已重置为线上发布版本，请检查后保存草稿",
                            type: "success",
                        });
                    }
                } catch (error) {
                    toast({
                        message: error?.message || "重置失败，请稍后重试",
                        type: "error",
                    });
                } finally {
                    this.resettingFromPublication = false;
                }
            },
            hasPublishedVersion() {
                if (
                    this.latestPublication &&
                    typeof this.latestPublication === "object"
                ) {
                    return true;
                }
                const controller = this.ensureController();
                if (!controller || !controller.postData) {
                    return false;
                }
                const status = sanitizeString(
                    controller.postData.Status ??
                        controller.postData.status ??
                        "",
                );
                return status.toLowerCase() === "published";
            },
            publishButtonLabel() {
                return this.hasPublishedVersion() ? "更新文章" : "发布文章";
            },
            publishStatusLabel() {
                if (this.publishing) {
                    return "正在更新线上版本";
                }
                return this.hasPublishedVersion()
                    ? "线上版本已就绪"
                    : "当前为草稿";
            },
            publishStatusDescription() {
                if (this.publishing) {
                    return "正在同步最新内容，请稍候...";
                }
                const timestamp = this.latestPublicationTimestamp();
                if (timestamp) {
                    return `最近发布于 ${timestamp}`;
                }
                return "发布后文章会立即同步至线上站点。";
            },
            buildPublishOptions() {
                const value = sanitizeString(this.publishAtInput || "");
                if (!value) {
                    this.publishAtError = "";
                    return { silent: false };
                }
                const parsed = toDate(value);
                if (!parsed) {
                    this.publishAtError =
                        "发布时间格式无效，请重新选择日期和时间。";
                    return null;
                }
                this.publishAtError = "";
                return { silent: false, publishedAt: parsed.toISOString() };
            },
            handlePublishAtInput(value) {
                this.publishAtManual = true;
                this.publishAtInput = sanitizeString(value || "");
                if (!this.publishAtInput) {
                    this.publishAtError = "";
                }
            },
            setPublishTimeToNow() {
                this.publishAtInput = this.formatLocalDateTimeInput(new Date());
                this.publishAtManual = true;
                this.publishAtError = "";
            },
            clearPublishTime() {
                this.publishAtInput = "";
                this.publishAtManual = true;
                this.publishAtError = "";
            },
            publishTimeHelpText() {
                if (this.publishAtInput) {
                    const formatted = this.formatDateTime(this.publishAtInput);
                    if (formatted) {
                        return `下次发布将使用 ${formatted}（本地时间）作为发布时间。`;
                    }
                }
                const latest = this.latestPublicationTimestamp();
                if (latest) {
                    return `未填写时将沿用最近的发布时间：${latest}。`;
                }
                return "未填写时将默认使用当前时间。";
            },
            updatePublishAtFromSource(source, { force = false } = {}) {
                const raw = this.resolvePublishedAt(source);
                const formatted = this.formatLocalDateTimeInput(raw);
                if (!formatted) {
                    return;
                }
                if (!force && this.publishAtManual && this.publishAtInput) {
                    return;
                }
                this.publishAtInput = formatted;
                if (force) {
                    this.publishAtManual = false;
                    this.publishAtError = "";
                }
            },
            resolvePublishedAt(source) {
                if (!source || typeof source !== "object") {
                    return "";
                }
                return sanitizeString(
                    source.PublishedAt ??
                        source.published_at ??
                        source.publishedAt ??
                        "",
                );
            },
            formatLocalDateTimeInput(value) {
                const date = toDate(value);
                if (!date) {
                    return "";
                }
                const pad = (num) => String(num).padStart(2, "0");
                const year = date.getFullYear();
                if (year < 1000) {
                    return "";
                }
                const paddedYear = String(year).padStart(4, "0");
                const month = pad(date.getMonth() + 1);
                const day = pad(date.getDate());
                const hour = pad(date.getHours());
                const minute = pad(date.getMinutes());
                return `${paddedYear}-${month}-${day}T${hour}:${minute}`;
            },
            latestPublicationTimestamp() {
                const publication = this.latestPublication;
                let publishedAt = "";
                if (publication && typeof publication === "object") {
                    publishedAt = sanitizeString(
                        publication.PublishedAt ??
                            publication.published_at ??
                            publication.publishedAt ??
                            publication.CreatedAt ??
                            publication.created_at ??
                            publication.createdAt ??
                            "",
                    );
                }
                if (!publishedAt) {
                    const controller = this.ensureController();
                    if (controller && controller.postData) {
                        publishedAt = sanitizeString(
                            controller.postData.PublishedAt ??
                                controller.postData.published_at ??
                                controller.postData.publishedAt ??
                                "",
                        );
                    }
                }
                if (!publishedAt) {
                    return "";
                }
                return this.formatDateTime(publishedAt);
            },
            tryAttachController() {
                if (
                    this.controller ||
                    !window.MilkdownV2 ||
                    !window.MilkdownV2.controller
                ) {
                    return;
                }
                this.attachController(window.MilkdownV2.controller);
                const snapshot =
                    typeof this.controller.getPostSnapshot === "function"
                        ? this.controller.getPostSnapshot()
                        : this.controller.postData;
                if (snapshot) {
                    this.syncPost(snapshot);
                }
            },
            ensureController() {
                if (!this.controller) {
                    this.tryAttachController();
                }
                return this.controller;
            },
            attachController(controller) {
                if (!controller || this.controller === controller) {
                    return;
                }
                this.controller = controller;
                if (typeof controller.getLatestPublication === "function") {
                    this.latestPublication =
                        controller.getLatestPublication() || null;
                } else if (controller.latestPublication) {
                    this.latestPublication = controller.latestPublication;
                }
                this.applyContentMetrics(controller.contentMetrics);
                this.updatePostTimestamps(controller.postData);
                this.syncTagsFromController(controller.postData);
                this.updatePublishAtFromSource(
                    this.latestPublication || controller.postData,
                );
            },
            syncPost(post) {
                if (!post || typeof post !== "object") {
                    return;
                }
                this.metadata.summary = sanitizeString(
                    post.Summary ?? post.summary ?? "",
                );
                const coverUrl = sanitizeString(
                    post.CoverURL ?? post.cover_url ?? "",
                );
                const coverWidth = sanitizeNumber(
                    post.CoverWidth ?? post.cover_width ?? 0,
                );
                const coverHeight = sanitizeNumber(
                    post.CoverHeight ?? post.cover_height ?? 0,
                );
                this.metadata.cover = {
                    url: coverUrl,
                    width: coverWidth,
                    height: coverHeight,
                };
                this.syncTagsFromController(post);
                this.updatePostTimestamps(post);
                this.updatePublishAtFromSource(this.latestPublication || post);
            },
            updatePostTimestamps(post) {
                if (!post || typeof post !== "object") {
                    this.postCreatedAt = "";
                    this.postUpdatedAt = "";
                    return;
                }
                const createdAt = sanitizeString(
                    post.CreatedAt ?? post.created_at ?? post.createdAt ?? "",
                );
                const updatedAt = sanitizeString(
                    post.UpdatedAt ?? post.updated_at ?? post.updatedAt ?? "",
                );
                this.postCreatedAt = createdAt;
                this.postUpdatedAt = updatedAt;
            },
            refreshStatus() {
                const controller = this.ensureController();
                if (!controller) {
                    return;
                }
                this.autoSaving = !!controller.autoSaving;
                this.autoSavePending = !!controller.autoSavePending;
                this.autoSaveError = sanitizeString(
                    controller.autoSaveError || "",
                );
                this.lastAutoSavedAt = toDate(controller.lastAutoSavedAt);
                const resolvedId = sanitizeString(
                    controller.postId || "new",
                ).trim();
                this.postId = resolvedId || "new";
                this.savingDraft = !!controller.loading;
                this.publishing = !!controller.publishing;
                if (typeof controller.getLatestPublication === "function") {
                    this.latestPublication =
                        controller.getLatestPublication() || null;
                } else {
                    this.latestPublication =
                        controller.latestPublication || null;
                }
                this.applyContentMetrics(controller.contentMetrics);
                this.updatePostTimestamps(controller.postData);
                this.syncTagsFromController(controller.postData);
                this.updatePublishAtFromSource(
                    this.latestPublication || controller.postData,
                );
            },
            applyContentMetrics(metrics) {
                this.contentMetrics = this.normalizeContentMetrics(metrics);
            },
            normalizeContentMetrics(metrics) {
                if (!metrics || typeof metrics !== "object") {
                    return { words: 0, characters: 0, paragraphs: 0 };
                }
                const words = Math.max(
                    0,
                    Math.round(sanitizeNumber(metrics.words)),
                );
                const characters = Math.max(
                    0,
                    Math.round(sanitizeNumber(metrics.characters)),
                );
                const paragraphs = Math.max(
                    0,
                    Math.round(sanitizeNumber(metrics.paragraphs)),
                );
                return { words, characters, paragraphs };
            },
            deriveTitleFromContent(content) {
                if (
                    window.MilkdownV2 &&
                    typeof window.MilkdownV2.deriveTitleFromMarkdown ===
                        "function"
                ) {
                    return sanitizeString(
                        window.MilkdownV2.deriveTitleFromMarkdown(content),
                    ).trim();
                }
                const source = sanitizeString(content);
                if (!source) {
                    return "";
                }
                const newlineIndex = source.indexOf("\n");
                const firstLine =
                    newlineIndex >= 0 ? source.slice(0, newlineIndex) : source;
                let trimmed = firstLine.trim();
                if (!trimmed) {
                    return "";
                }
                if (trimmed.startsWith("#")) {
                    trimmed = trimmed.replace(/^#+/, "").trim();
                    trimmed = trimmed.replace(/#+$/, "").trim();
                }
                return trimmed;
            },
            normalizeTag(tag) {
                if (tag === null || tag === undefined) {
                    return null;
                }
                let source = {};
                if (typeof tag === "object") {
                    source = { ...tag };
                } else {
                    const numeric = Number(tag);
                    if (!Number.isFinite(numeric)) {
                        return null;
                    }
                    source = { id: numeric };
                }
                const idCandidate = source.ID ?? source.id ?? source.Id;
                const id = Number(idCandidate);
                if (!Number.isFinite(id)) {
                    return null;
                }
                const nameCandidate = sanitizeString(
                    source.Name ?? source.name ?? "",
                ).trim();
                const slugCandidate = sanitizeString(
                    source.Slug ?? source.slug ?? "",
                ).trim();
                const name = nameCandidate || `标签 #${id}`;
                const normalized = {
                    id,
                    ID: id,
                    name,
                    Name: name,
                };
                if (slugCandidate) {
                    normalized.slug = slugCandidate;
                    normalized.Slug = slugCandidate;
                }
                return normalized;
            },
            normalizeTags(tags) {
                if (!Array.isArray(tags)) {
                    return [];
                }
                const normalized = [];
                const seen = new Set();
                for (const item of tags) {
                    const normalizedTag = this.normalizeTag(item);
                    if (!normalizedTag) {
                        continue;
                    }
                    if (seen.has(normalizedTag.id)) {
                        continue;
                    }
                    seen.add(normalizedTag.id);
                    normalized.push(normalizedTag);
                }
                return normalized;
            },
            tagId(tag) {
                if (tag && typeof tag === "object") {
                    const value = tag.id ?? tag.ID ?? tag.Id;
                    const numeric = Number(value);
                    return Number.isFinite(numeric) ? numeric : null;
                }
                const numeric = Number(tag);
                return Number.isFinite(numeric) ? numeric : null;
            },
            resolveTagById(id) {
                const numeric = this.tagId(id);
                if (numeric === null) {
                    return null;
                }
                const sources = [];
                if (Array.isArray(this.availableTags)) {
                    sources.push(...this.availableTags);
                }
                if (Array.isArray(this.metadata?.tags)) {
                    sources.push(...this.metadata.tags);
                }
                for (const candidate of sources) {
                    const candidateId = this.tagId(candidate);
                    if (candidateId === numeric) {
                        return this.normalizeTag(candidate);
                    }
                }
                return this.normalizeTag({ id: numeric });
            },
            syncTagsFromController(post) {
                const source =
                    post && typeof post === "object"
                        ? (post.Tags ?? post.tags ?? [])
                        : [];
                const normalized = this.normalizeTags(source);
                this.metadata.tags = normalized;
                this.selectedTagIDs = normalized.map((tag) => tag.id);
            },
            isTagSelected(tag) {
                const id = this.tagId(tag);
                if (id === null) {
                    return false;
                }
                return this.selectedTagIDs.some((value) => value === id);
            },
            toggleTag(tag) {
                const id = this.tagId(tag);
                if (id === null) {
                    return;
                }
                if (this.isTagSelected(id)) {
                    this.selectedTagIDs = this.selectedTagIDs.filter(
                        (value) => value !== id,
                    );
                } else {
                    this.selectedTagIDs = [...this.selectedTagIDs, id];
                }
                this.applyTagSelection();
            },
            applyTagSelection() {
                const uniqueIds = [];
                for (const value of this.selectedTagIDs) {
                    const id = this.tagId(value);
                    if (id === null || uniqueIds.includes(id)) {
                        continue;
                    }
                    uniqueIds.push(id);
                }
                this.selectedTagIDs = uniqueIds;
                const selected = uniqueIds
                    .map((id) => this.resolveTagById(id))
                    .filter(Boolean)
                    .map((tag) => this.normalizeTag(tag));
                this.metadata.tags = selected;
                const controller = this.ensureController();
                if (controller) {
                    if (typeof controller.setTagIds === "function") {
                        controller.setTagIds(uniqueIds, this.availableTags);
                    } else if (typeof controller.setTags === "function") {
                        const payload = selected.map((tag) => ({
                            ID: tag.id,
                            Name: tag.name,
                            Slug: tag.slug,
                        }));
                        controller.setTags(payload);
                    }
                }
            },
            formatNumber(value) {
                if (!this.numberFormatter) {
                    this.numberFormatter = new Intl.NumberFormat("zh-CN");
                }
                const sanitized = Math.max(
                    0,
                    Math.round(sanitizeNumber(value)),
                );
                return this.numberFormatter.format(sanitized);
            },
            paragraphCountLabel() {
                const paragraphs = Math.max(
                    0,
                    Math.round(sanitizeNumber(this.contentMetrics?.paragraphs)),
                );
                return this.formatNumber(paragraphs);
            },
            statisticsUpdatedLabel() {
                const formatted = this.formatDateTime(this.postUpdatedAt);
                return formatted || "N/A";
            },
            statisticsCreatedLabel() {
                const formatted = this.formatDateTime(this.postCreatedAt);
                return formatted || "N/A";
            },
            autoSaveIndicatorClasses() {
                if (this.autoSaveError) {
                    return "bg-rose-500/80";
                }
                if (this.autoSaving) {
                    return "animate-pulse bg-blue-500/80";
                }
                if (this.autoSavePending) {
                    return "bg-amber-500/80";
                }
                return "bg-emerald-500/80";
            },
            autoSaveLabel() {
                if (this.autoSaveError) {
                    return this.autoSaveError;
                }
                if (this.autoSaving) {
                    return "自动保存中...";
                }
                if (this.autoSavePending) {
                    return "存在未保存的更改";
                }
                if (this.lastAutoSavedAt) {
                    return `已保存 ${this.relativeTime(this.lastAutoSavedAt)}`;
                }
                return "草稿模式已启用";
            },
            autoSaveDescription() {
                if (this.autoSaveError) {
                    return this.autoSaveError;
                }
                if (this.autoSaving) {
                    return "正在写入最新内容，请勿关闭页面。";
                }
                if (this.autoSavePending) {
                    return "有新的更改等待保存，稍后将自动提交。";
                }
                if (this.lastAutoSavedAt) {
                    return `最近保存于 ${this.formatDateTime(this.lastAutoSavedAt)}。`;
                }
                return "系统会定期自动保存草稿，确保写作内容安全。";
            },
            relativeTime(date) {
                const target = toDate(date);
                if (!target) {
                    return "";
                }
                const now = new Date();
                const diffSeconds = Math.floor(
                    (now.getTime() - target.getTime()) / 1000,
                );
                if (diffSeconds < 60) {
                    return "刚刚";
                }
                if (diffSeconds < 3600) {
                    const minutes = Math.max(1, Math.floor(diffSeconds / 60));
                    return `${minutes} 分钟前`;
                }
                const hours = Math.floor(diffSeconds / 3600);
                if (hours < 24) {
                    return `${hours} 小时前`;
                }
                const days = Math.floor(diffSeconds / 86400);
                return `${days} 天前`;
            },
            formatDateTime(date) {
                const target = toDate(date);
                if (!target) {
                    return "";
                }
                return target.toLocaleString("zh-CN", {
                    month: "short",
                    day: "numeric",
                    hour: "2-digit",
                    minute: "2-digit",
                });
            },
            togglePanel(force) {
                this.panelOpen =
                    typeof force === "boolean" ? force : !this.panelOpen;
            },
            closePanel() {
                this.panelOpen = false;
            },
            handleSummaryChange(value) {
                const controller = this.ensureController();
                if (
                    !controller ||
                    typeof controller.setSummary !== "function"
                ) {
                    return;
                }
                controller.setSummary(value);
            },
            summaryUsageLabel() {
                if (!this.summaryUsage) {
                    return "";
                }
                const prompt = sanitizeNumber(
                    this.summaryUsage.prompt_tokens ??
                        this.summaryUsage.promptTokens ??
                        0,
                );
                const completion = sanitizeNumber(
                    this.summaryUsage.completion_tokens ??
                        this.summaryUsage.completionTokens ??
                        0,
                );
                if (!prompt && !completion) {
                    return "未提供用量信息";
                }
                return `Prompt ${prompt} · Completion ${completion}`;
            },
            inlineAIUsageLabel() {
                const usage = this.inlineAI?.usage;
                if (!usage) {
                    return "";
                }
                const prompt = sanitizeNumber(
                    usage.prompt_tokens ?? usage.promptTokens ?? 0,
                );
                const completion = sanitizeNumber(
                    usage.completion_tokens ?? usage.completionTokens ?? 0,
                );
                if (!prompt && !completion) {
                    return "";
                }
                return `Prompt ${prompt} · Completion ${completion}`;
            },
            closeInlineAI() {
                this.inlineAI.open = false;
                this.inlineAI.loading = false;
                this.inlineAI.error = "";
                this.inlineAI.instruction = "";
                this.inlineAI.suggestion = "";
                this.inlineAI.usage = null;
                if (window.MilkdownV2?.inlineAI?.hideToolbar) {
                    try {
                        window.MilkdownV2.inlineAI.hideToolbar();
                    } catch (error) {
                        console.warn(
                            "[post-editor] 关闭 AI Chat 弹窗时隐藏工具条失败",
                            error,
                        );
                    }
                }
            },
            async runInlineAIChat() {
                if (this.inlineAI.loading) {
                    return;
                }
                const selection = this.inlineAI.selection || {};
                const selectionText = sanitizeString(
                    selection.normalized || selection.text || "",
                );
                if (!selectionText.trim()) {
                    toast({
                        message: "请选择需要改写的段落后再试",
                        type: "warning",
                    });
                    return;
                }
                const instruction = sanitizeString(
                    this.inlineAI.instruction,
                ).trim();
                if (!instruction) {
                    toast({ message: "请输入改写指令", type: "warning" });
                    return;
                }
                this.inlineAI.loading = true;
                this.inlineAI.error = "";
                this.inlineAI.suggestion = "";
                this.inlineAI.usage = null;
                try {
                    const response = await fetch("/admin/api/posts/chat", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            selection: selectionText,
                            instruction,
                            context: sanitizeString(selection.context || ""),
                        }),
                    });
                    const data = await response.json();
                    if (!response.ok) {
                        const message = sanitizeString(
                            data?.error ||
                                data?.message ||
                                "AI Chat 请求失败，请稍后重试",
                        );
                        throw new Error(
                            message || "AI Chat 请求失败，请稍后重试",
                        );
                    }
                    const suggestion = sanitizeString(
                        data?.content ?? data?.result ?? "",
                    );
                    if (!suggestion.trim()) {
                        throw new Error("AI Chat 未返回内容，请稍后重试");
                    }
                    this.inlineAI.suggestion = suggestion;
                    this.inlineAI.usage = data?.usage || null;
                    toast({ message: "AI 已返回改写建议", type: "success" });
                } catch (error) {
                    const message = sanitizeString(
                        error?.message || "AI Chat 请求失败，请稍后重试",
                    );
                    this.inlineAI.error = message;
                    toast({ message, type: "error" });
                } finally {
                    this.inlineAI.loading = false;
                }
            },
            applyInlineAISuggestion() {
                const suggestion = sanitizeString(
                    this.inlineAI.suggestion,
                ).trim();
                if (!suggestion) {
                    this.closeInlineAI();
                    return;
                }
                const selection = this.inlineAI.selection || {};
                const from = selection.from;
                const to = selection.to;
                if (
                    !Number.isFinite(from) ||
                    !Number.isFinite(to) ||
                    from === to
                ) {
                    toast({
                        message: "无法定位原始选区，请重新选择后再试",
                        type: "error",
                    });
                    return;
                }
                try {
                    const applied = window.MilkdownV2?.inlineAI?.applyChange({
                        from,
                        to,
                        expected: selection.normalized || selection.text || "",
                        replacement: suggestion,
                    });
                    if (!applied) {
                        throw new Error("未能应用 AI 改写内容");
                    }
                    this.closeInlineAI();
                    toast({ message: "已应用 AI 改写内容", type: "success" });
                    this.scheduleEditorTocRefresh();
                } catch (error) {
                    const message = sanitizeString(
                        error?.message || "应用改写内容失败，请稍后重试",
                    );
                    toast({ message, type: "error" });
                }
            },
            async copyInlineAISuggestion() {
                const suggestion = sanitizeString(
                    this.inlineAI.suggestion,
                ).trim();
                if (!suggestion) {
                    toast({ message: "暂无可复制的内容", type: "warning" });
                    return;
                }
                if (!navigator?.clipboard?.writeText) {
                    toast({
                        message: "浏览器不支持快速复制，请手动复制文本",
                        type: "warning",
                    });
                    return;
                }
                try {
                    await navigator.clipboard.writeText(suggestion);
                    toast({ message: "已复制到剪贴板", type: "success" });
                } catch (error) {
                    toast({
                        message: "复制失败，请手动选择文本",
                        type: "error",
                    });
                }
            },
            async ensureOptimizationPreviewMount(target) {
                const preview = this.optimizationPreviews?.[target];
                if (!preview) {
                    return null;
                }
                if (preview.mount) {
                    return preview.mount;
                }
                await this.$nextTick();
                const refName =
                    target === "optimized"
                        ? "optimizedContentPreview"
                        : "optimizationSourcePreview";
                const mount = this.$refs?.[refName] || null;
                preview.mount = mount || null;
                return preview.mount;
            },
            previewPlaceholder(target) {
                if (target === "optimized") {
                    return '<p class="text-xs text-emerald-500/70 dark:text-emerald-200/70">等待优化结果...</p>';
                }
                return '<p class="text-xs text-slate-400 dark:text-slate-500">暂无内容</p>';
            },
            async destroyOptimizationPreview(
                target,
                { keepContainer = false } = {},
            ) {
                const preview = this.optimizationPreviews?.[target];
                if (!preview) {
                    return;
                }
                const instance = preview.instance;
                preview.instance = null;
                preview.ready = false;
                preview.rendering = null;
                if (instance && typeof instance.destroy === "function") {
                    try {
                        const result = instance.destroy();
                        if (result && typeof result.then === "function") {
                            await result;
                        }
                    } catch (error) {
                        console.warn("[post-editor] 预览销毁失败", error);
                    }
                }
                if (!keepContainer && preview.mount) {
                    preview.mount.innerHTML = "";
                }
            },
            async renderOptimizationPreview(target, markdown) {
                const preview = this.optimizationPreviews?.[target];
                if (!preview) {
                    return;
                }
                if (preview.rendering) {
                    try {
                        await preview.rendering;
                    } catch (error) {
                        console.warn("[post-editor] 预览渲染冲突", error);
                    }
                }
                const task = (async () => {
                    const mount =
                        await this.ensureOptimizationPreviewMount(target);
                    const value = sanitizeString(markdown).trim();
                    if (!mount) {
                        return;
                    }
                    if (!value) {
                        await this.destroyOptimizationPreview(target, {
                            keepContainer: true,
                        });
                        mount.innerHTML = this.previewPlaceholder(target);
                        preview.ready = false;
                        return;
                    }

                    const renderFallback = () => {
                        mount.innerHTML = fallbackMarkdownToHtml(value);
                        preview.instance = null;
                        preview.ready = true;
                    };

                    if (!window.MilkdownV2) {
                        renderFallback();
                        return;
                    }

                    try {
                        let viewer = preview.instance;
                        if (
                            viewer &&
                            typeof viewer.setMarkdown === "function"
                        ) {
                            const result = viewer.setMarkdown(value);
                            if (result && typeof result.then === "function") {
                                await result;
                            }
                            preview.ready = true;
                            return;
                        }

                        await this.destroyOptimizationPreview(target, {
                            keepContainer: true,
                        });
                        mount.innerHTML = "";

                        if (
                            typeof window.MilkdownV2.createReadOnlyViewer ===
                            "function"
                        ) {
                            viewer =
                                await window.MilkdownV2.createReadOnlyViewer({
                                    mount,
                                    markdown: value,
                                });
                        } else {
                            const CrepeCtor =
                                window.MilkdownV2?.crepe?.constructor;
                            if (typeof CrepeCtor === "function") {
                                viewer = new CrepeCtor({
                                    root: mount,
                                    defaultValue: value || "# ",
                                });
                                if (typeof viewer.setReadonly === "function") {
                                    viewer.setReadonly(true);
                                }
                                const created = viewer.create?.();
                                if (
                                    created &&
                                    typeof created.then === "function"
                                ) {
                                    await created;
                                }
                                if (typeof viewer.setMarkdown === "function") {
                                    const result = viewer.setMarkdown(value);
                                    if (
                                        result &&
                                        typeof result.then === "function"
                                    ) {
                                        await result;
                                    }
                                }
                            }
                        }

                        if (!viewer) {
                            renderFallback();
                            return;
                        }

                        preview.instance = viewer;
                        preview.ready = true;
                    } catch (error) {
                        console.warn("[post-editor] 渲染预览失败", error);
                        await this.destroyOptimizationPreview(target, {
                            keepContainer: true,
                        });
                        renderFallback();
                    }
                })();
                preview.rendering = task;
                try {
                    await task;
                } finally {
                    if (preview.rendering === task) {
                        preview.rendering = null;
                    }
                }
            },
            async optimizeContent() {
                if (this.optimizingContent) {
                    return;
                }
                this.closeStatisticsMenu();
                const controller = this.ensureController();
                if (!controller) {
                    toast({
                        message: "编辑器尚未就绪，请稍后重试",
                        type: "warning",
                    });
                    return;
                }
                const getMarkdown = window.MilkdownV2?.getMarkdown;
                const sourceContent =
                    typeof getMarkdown === "function"
                        ? getMarkdown()
                        : sanitizeString(controller.postData?.Content ?? "");
                const trimmedContent = sourceContent.trim();
                if (!trimmedContent) {
                    toast({
                        message: "请先填写文章正文再尝试全文优化",
                        type: "warning",
                    });
                    return;
                }
                const derivedTitle = this.deriveTitleFromContent(sourceContent);
                const title =
                    derivedTitle ||
                    sanitizeString(controller.postData?.Title ?? "");
                if (
                    controller &&
                    controller.postData &&
                    (derivedTitle || title)
                ) {
                    controller.postData.Title = title;
                    controller.postData.title = title;
                }
                const wasModalOpen = this.optimizationModal;
                const previousOptimized = this.optimizedContent;
                const previousUsage = this.optimizationUsage;
                const hadResult =
                    typeof previousOptimized === "string" &&
                    previousOptimized.trim().length > 0;
                this.optimizingContent = true;
                this.optimizationSource = sourceContent;
                void this.renderOptimizationPreview("source", sourceContent);
                this.optimizedContent = "";
                void this.renderOptimizationPreview("optimized", "");
                this.optimizationUsage = null;
                if (!wasModalOpen) {
                    this.optimizationModal = true;
                }
                try {
                    const response = await fetch("/admin/api/posts/optimize", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            title,
                            content: trimmedContent,
                        }),
                    });
                    const data = await response.json();
                    if (!response.ok) {
                        const message =
                            data?.error ||
                            data?.message ||
                            "全文优化失败，请稍后重试";
                        throw new Error(message);
                    }
                    const optimized = sanitizeString(
                        data?.optimized_content ?? data?.optimizedContent ?? "",
                    );
                    if (!optimized.trim()) {
                        throw new Error("AI 全文优化未返回内容，请稍后重试");
                    }
                    this.optimizedContent = optimized;
                    void this.renderOptimizationPreview("optimized", optimized);
                    this.optimizationUsage = data?.usage || null;
                    if (!wasModalOpen) {
                        this.optimizationModal = true;
                    }
                    toast({
                        message: "已生成优化提案，请确认内容",
                        type: "success",
                    });
                } catch (error) {
                    toast({
                        message: error?.message || "全文优化失败，请稍后重试",
                        type: "error",
                    });
                    if (hadResult) {
                        this.optimizedContent = previousOptimized;
                        void this.renderOptimizationPreview(
                            "optimized",
                            previousOptimized || "",
                        );
                        this.optimizationUsage = previousUsage || null;
                        this.optimizationModal = wasModalOpen || hadResult;
                    } else if (!wasModalOpen) {
                        this.optimizationModal = false;
                    }
                } finally {
                    this.optimizingContent = false;
                }
            },
            closeOptimizationModal() {
                this.optimizationModal = false;
            },
            async applyOptimization() {
                const optimized = sanitizeString(this.optimizedContent);
                if (!optimized.trim()) {
                    this.closeOptimizationModal();
                    return;
                }
                const controller = this.ensureController();
                let applied = false;
                const crepe = window.MilkdownV2?.crepe;
                if (crepe && typeof crepe.setMarkdown === "function") {
                    try {
                        const result = crepe.setMarkdown(optimized);
                        if (result && typeof result.then === "function") {
                            applied = await result;
                        } else if (result !== false) {
                            applied = true;
                        }
                    } catch (error) {
                        console.warn(
                            "[post-editor] crepe.setMarkdown 调用失败",
                            error,
                        );
                    }
                }
                if (controller) {
                    controller.postData.Content = optimized;
                    controller.postData.content = optimized;
                    controller.currentContent = optimized;
                    if (typeof controller.markDirty === "function") {
                        controller.markDirty();
                    } else {
                        controller.autoSavePending = true;
                        controller.autoSaveError = "";
                    }
                    if (typeof controller.notifyPostChange === "function") {
                        controller.notifyPostChange("content");
                    }
                }
                this.optimizationSource = optimized;
                void this.renderOptimizationPreview("source", optimized);
                if (!applied) {
                    toast({
                        message: "优化内容已生成，请确认编辑器中的展示是否同步",
                        type: "info",
                    });
                } else {
                    toast({ message: "已替换为优化后的正文", type: "success" });
                }
                this.scheduleEditorTocRefresh();
                this.closeOptimizationModal();
            },
            async generateSummary() {
                if (this.generatingSummary) {
                    return;
                }
                const controller = this.ensureController();
                if (!controller) {
                    toast({
                        message: "编辑器尚未就绪，请稍后重试",
                        type: "warning",
                    });
                    return;
                }
                const getMarkdown = window.MilkdownV2?.getMarkdown;
                const content =
                    typeof getMarkdown === "function"
                        ? getMarkdown()
                        : sanitizeString(controller.postData?.Content ?? "");
                const derivedTitle = this.deriveTitleFromContent(content);
                const title =
                    derivedTitle ||
                    sanitizeString(controller.postData?.Title ?? "");
                if (
                    controller &&
                    controller.postData &&
                    (derivedTitle || title)
                ) {
                    controller.postData.Title = title;
                    controller.postData.title = title;
                }
                if (!title && !content) {
                    toast({
                        message: "请先填写标题或正文后再生成摘要",
                        type: "warning",
                    });
                    return;
                }
                this.generatingSummary = true;
                this.summaryUsage = null;
                try {
                    const response = await fetch("/admin/api/posts/summary", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ title, content }),
                    });
                    const data = await response.json();
                    if (!response.ok) {
                        const message =
                            data?.error ||
                            data?.message ||
                            "生成摘要失败，请稍后重试";
                        throw new Error(message);
                    }
                    const summary = sanitizeString(data.summary);
                    if (!summary.trim()) {
                        throw new Error("AI 摘要服务未返回内容，请稍后重试");
                    }
                    this.applySummary(summary, data.usage || null);
                    toast({
                        message: "已生成 AI 摘要，请确认内容",
                        type: "success",
                    });
                } catch (error) {
                    toast({
                        message: error?.message || "生成摘要失败，请稍后重试",
                        type: "error",
                    });
                } finally {
                    this.generatingSummary = false;
                }
            },
            applySummary(summary, usage) {
                this.metadata.summary = summary;
                this.summaryUsage = usage || null;
                const controller = this.ensureController();
                if (controller && typeof controller.setSummary === "function") {
                    controller.setSummary(summary);
                }
            },
            openCoverPicker() {
                if (this.$refs.coverInput) {
                    this.$refs.coverInput.click();
                }
            },
            handleCoverFile(event) {
                const input = event?.target;
                const [file] = input?.files || [];
                if (!file) {
                    return;
                }
                if (typeof window.Cropper === "undefined") {
                    toast({
                        message: "封面裁剪模块尚未加载，请刷新页面后重试",
                        type: "error",
                    });
                    return;
                }
                this.resetCropper();
                this.coverSource = URL.createObjectURL(file);
                this.coverModal = true;
                this.initCropperWhenReady();
                if (input) {
                    input.value = "";
                }
            },
            initCropperWhenReady() {
                this.$nextTick(() => {
                    const image = this.$refs.cropperImage;
                    if (!image || typeof window.Cropper === "undefined") {
                        return;
                    }
                    this.cropper = new window.Cropper(image, {
                        aspectRatio: this.aspectValue(),
                        viewMode: 2,
                        autoCropArea: 1,
                        background: false,
                        responsive: true,
                        movable: true,
                        zoomable: true,
                        ready: () => {
                            this.adjustCropBox();
                        },
                    });
                });
            },
            adjustCropBox() {
                if (!this.cropper) {
                    return;
                }
                this.cropper.setAspectRatio(this.aspectValue());
            },
            confirmCrop() {
                if (!this.cropper || this.uploadingCover) {
                    return;
                }
                this.uploadingCover = true;
                const canvas = this.cropper.getCroppedCanvas({
                    imageSmoothingEnabled: true,
                    imageSmoothingQuality: "high",
                    maxWidth: 2560,
                    maxHeight: 2560,
                });
                if (!canvas) {
                    this.uploadingCover = false;
                    toast({
                        message: "生成裁剪图片失败，请重试",
                        type: "error",
                    });
                    return;
                }
                // 限制导出尺寸与质量，避免巨大封面导致后端超载
                canvas.toBlob(
                    async (blob) => {
                        if (!blob) {
                            this.uploadingCover = false;
                            toast({
                                message: "生成裁剪图片失败，请重试",
                                type: "error",
                            });
                            return;
                        }
                        try {
                            await this.uploadCroppedImage(blob);
                            toast({ message: "封面已更新", type: "success" });
                        } catch (error) {
                            toast({
                                message:
                                    error?.message ||
                                    "封面上传失败，请稍后重试",
                                type: "error",
                            });
                        } finally {
                            this.uploadingCover = false;
                        }
                    },
                    "image/jpeg",
                    0.85,
                );
            },
            async uploadCroppedImage(blob) {
                const formData = new FormData();
                formData.append("image", blob, `cover-${Date.now()}.jpg`);
                const response = await fetch("/admin/api/upload/image", {
                    method: "POST",
                    body: formData,
                });
                const data = await response.json();
                if (!response.ok || data?.success !== 1) {
                    const message =
                        data?.error || data?.message || "封面上传失败";
                    throw new Error(message);
                }
                const url = sanitizeString(
                    data?.data?.url || data?.data?.filePath || "",
                );
                const width = sanitizeNumber(
                    data?.data?.width || data?.data?.Width || 0,
                );
                const height = sanitizeNumber(
                    data?.data?.height || data?.data?.Height || 0,
                );
                if (!url) {
                    throw new Error("封面上传成功但未返回访问地址");
                }
                this.applyCover(url, width, height);
                this.closeCropper();
            },
            applyCover(url, width, height) {
                this.metadata.cover = { url, width, height };
                const controller = this.ensureController();
                if (controller && typeof controller.setCover === "function") {
                    controller.setCover({ url, width, height });
                }
            },
            removeCover() {
                this.metadata.cover = { url: "", width: 0, height: 0 };
                const controller = this.ensureController();
                if (controller) {
                    if (typeof controller.clearCover === "function") {
                        controller.clearCover();
                    } else if (typeof controller.setCover === "function") {
                        controller.setCover({ url: "", width: 0, height: 0 });
                    }
                }
            },
            reCropCover() {
                const { url, width, height } = this.metadata.cover || {};
                if (!url) {
                    return;
                }
                try {
                    const target = new URL(url, window.location.origin);
                    if (target.origin !== window.location.origin) {
                        toast({
                            message: "该封面来源于外部链接，请重新上传新的封面",
                            type: "warning",
                        });
                        return;
                    }
                } catch (error) {
                    return;
                }
                if (typeof window.Cropper === "undefined") {
                    toast({
                        message: "封面裁剪模块尚未加载，请刷新页面后重试",
                        type: "error",
                    });
                    return;
                }
                if (width > 0 && height > 0) {
                    this.cropAspect = width >= height ? "16:9" : "3:4";
                }
                this.resetCropper();
                this.coverSource = url;
                this.coverModal = true;
                this.initCropperWhenReady();
            },
            closeCropper() {
                this.resetCropper();
                if (this.coverSource && this.coverSource.startsWith("blob:")) {
                    URL.revokeObjectURL(this.coverSource);
                }
                this.coverModal = false;
                this.coverSource = "";
            },
            resetCropper() {
                if (this.cropper) {
                    this.cropper.destroy();
                    this.cropper = null;
                }
            },
            setAspect(ratio) {
                this.cropAspect = ratio;
                if (this.cropper) {
                    this.cropper.setAspectRatio(this.aspectValue());
                }
            },
            aspectValue() {
                return this.cropAspect === "3:4" ? 3 / 4 : 16 / 9;
            },
            formatCoverSize() {
                const { width, height } = this.metadata.cover || {};
                if (!width || !height) {
                    return "未知尺寸";
                }
                return `${width} × ${height} px`;
            },
            async triggerSave() {
                if (this.savingDraft) {
                    return;
                }
                this.collapseQuickActions();
                if (
                    !window.MilkdownV2 ||
                    typeof window.MilkdownV2.saveDraft !== "function"
                ) {
                    toast({
                        message: "保存功能暂不可用，请稍后重试",
                        type: "error",
                    });
                    return;
                }
                this.savingDraft = true;
                try {
                    await window.MilkdownV2.saveDraft({
                        redirectOnCreate: false,
                        silent: false,
                        notifyOnSilent: true,
                        useLoadingState: true,
                    });
                } catch (error) {
                    toast({
                        message: error?.message || "保存失败，请稍后重试",
                        type: "error",
                    });
                } finally {
                    this.savingDraft = false;
                    this.refreshStatus();
                }
            },
            formatCoverSizeLegacy() {
                return this.formatCoverSize();
            },
        }));
    });
</script>
<script type="module" src="/static/dist/assets/milkdown_v2.js"></script>
{{end}}
