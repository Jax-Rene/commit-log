
# Repository Guidelines

Building a blog that is clear, maintainable, beautiful, and elegant requires consistent progress across architecture, code, design, and collaboration. This guide summarizes the team's best practices and must be followed when putting them into action.

## Vision and Design Philosophy
- **Clarity**: Any new member should understand the directory structure and primary dependencies within 30 minutes. Keep names concise and remove duplicate logic.
- **Reliability**: Every change must include the minimum necessary tests or validation steps to ensure a stable production experience.
- **Elegance**: Interfaces and interactions follow the principles of contrast, repetition, alignment, and proximity. Continuously refine details and reduce visual noise.
- **Evolvability**: Each module has a single responsibility, making replacements and extensions easy. Avoid introducing new technologies that conflict with the existing stack.

## Architectural Overview
- `cmd/server/main.go` is the only entry point. It initializes the database, router, configuration, and other dependencies. Business logic must not be added here.
- `internal/db`, `internal/handler`, `internal/router`, and `internal/service` host data models, HTTP entry points, route orchestration, and business services respectively. Place new private packages under `internal` to maintain encapsulation.
- Templates live in `web/template/{layout,admin}`. Keep the accompanying Alpine.js fragments in the directory with the same name. The Tailwind source file is `web/static/css/input.css`; build it with Vite and output to `web/static/dist`.
- Operations and product documentation are stored in `document/*.md`. Demo data is generated by `scripts/generate_test_data.go`; do not modify SQLite manually.

## Backend Development Guidelines
- Handlers handle input validation and response assembly; isolate business rules in services and delegate data access to the DB layer.
- Isolate third-party dependencies via interfaces. Use mocks or in-memory implementations in unit tests to cover critical paths.
- Place migration scripts and batch jobs in `scripts/` or dedicated packages to avoid scattering them across business directories.
- Run `gofmt` or `goimports` before committing. Use lower_snake_case for package names and PascalCase for structs and interfaces.

## Frontend Development Guidelines
- Align template names with the corresponding Handler and Service to keep the source traceable. Move shared components into `components` to reduce duplication.
- Order Tailwind class names by layout → component → state. Treat the build output directory `web/static/dist` as read-only. Reuse or extend existing styles before adding a new component.
- Keep Alpine.js state logic concise, balancing reactivity with declarative expressions. Use semantic names for HTMX requests and explicitly handle loading and error states.
- Follow the four design principles: use contrast to emphasize hierarchy, repetition to unify style, alignment to maintain order, and proximity to group related content.

## Build and Run
- `make run`: Start the service with production configuration on `:8080` for build acceptance.
- `make dev`: Start in debug mode with Gin Debug, template hot reload, and verbose logging enabled.
- `pnpm run build`: Use Vite to compile frontend assets and output them to `web/static/dist`.
- `go run scripts/generate_test_data.go`: Refresh demo data to validate backend filtering, search, and other critical scenarios.

## Testing and Quality Assurance
- Create `*_test.go` files alongside implementations, preferring table-driven tests. Run `make test` before committing.
- Document manual verification steps for frontend changes, covering critical scenarios such as rich text, uploads, and HTMX flows.
- When introducing new fields or data structures, update the demo data scripts and UI presentation simultaneously to maintain end-to-end alignment.
- If a regression occurs, add automated tests or scripts to ensure the defect does not recur.

## Submission and Review Process
- Use Conventional Commits for commit messages (for example, `feat(upload): ...`, `fix(router): ...`) with scopes aligned to the package or template you modified.
- PR descriptions must include the intent of the change, related requirements or issues, verification commands, and before/after screenshots or recordings for UI changes.
- Reviewers prioritize behavioral changes, potential regressions, test coverage, and code readability. Confirm that both CI and local verification pass before merging.

## Technology Stack Rules
- Backend: Golang + Gin + GORM + SQLite. Reuse existing abstractions and middleware whenever possible.
- Frontend: HTMX + Tailwind CSS + Alpine.js. Document the motivation and trade-offs before introducing any new dependency and assess the impact in advance.

## Routine Maintenance
- Review this guide regularly to keep the documentation, examples, and implementation aligned.
- Every new member must read through this guide on day one to understand the team agreements.
- When the guide and actual practices diverge, update the guide or fix the code first to keep the rules relevant.

By following these principles, the team can consistently deliver a blog product that balances engineering quality with visual polish. Continue to collect new insights in practice and keep iterating on this guide.
